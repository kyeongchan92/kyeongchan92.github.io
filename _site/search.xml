<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title>도커 컨테이너의 메모리 옵션</title>
      <url>/2023/12/11/docker-memory-options/</url>
      <content type="text">AWS ECS에서 container 소프트제한을 걸어두고 gunicorn worker를 1보다 높게 설정해놨는데 workder가 메모리 oom으로 인해 1개씩 가끔 죽는 현상이 있었다.
메모리 사용률을 확인해보니 간당간당하게 소프트제한에 다다르고 있었다. 왜냐면 worker 수만큼 곱해졌기 때문이다.
한참 알아보던 중, 도커 컨테이너에서 soft 및 hard 메모리 제한이 있다는걸 알게됐다. 다음 글을
번역했다 : Runtime options with Memory, CPUs, and GPUs



기본적으로, 컨테이너는 리소스 제한이 없다. 그리고 호스트의 커널 스케줄러가 허용하기만 한다면 주어진 리소스를 원하는 만큼 사용한다.

도커에서 컨테이너가 사용할 수 있는 메모리와 CPU를 컨트롤할 수 있다.

메모리

메모리 부족의 위험성 이해하기

컨테이너가 호스트의 메모리를 너무 많이 사용하게 하는걸 막아야한다.
리눅스에서는 커널이 충분한 메모리가 없다고 판단하면 OOME(Out of Memory Exception)을 내뱉고, 메모리를 확보하기위해 프로세스를 죽이기 시작한다(이게 계속 gunicorn 프로세스가 죽었던
이유구나..).
도커나 다른 다른 어플리케이션을 포함해서 어느 프로세스든 죽을 수 있다. 만약 중요한 프로세스가 kill되면? 전체 시스템이 다운될 것이다.

도커는 이런 위험을 피하기 위해 노력한다. 도커 대몬에 OOM 우선순위를 적용시키는 것이다. 그렇게 해서 다른 시스템
프로세스보다 죽을 가능성을 낮춘다.
각 컨테이너에는 OOM 우선순위를 적용하지 않는다. 도커 대몬에 적용함으로써 개별 컨테이너를 종료할 가능성을 높이고, 도커 대몬이나 다른 시스템 프로세스가 죽을 확률을 낮춘다.

--oom-score-adj↗
설정은 [-1000, 1000]사이의 숫자로 설정하여, 메모리 부족시 어떤 컨테이너를 먼저 죽일지 설정하게 해준다. 극단적으로 음수로 설정하면 안죽는 것이다.
--oom-kill-disable↗ 설정은 메모리 부족시에도 해당 컨테이너를 죽지 않게 할수도 있다. 하지만 이런 설정을 사용하는 것은 권장되지 않는다.

OOM 위험을 줄이려면?

다음과 같은 방법이 있다.


  컨테이너가 사용할 수 있는 메모리 양을 아래 설명된 대로 설정한다.
  Docker 호스트에서 swap을 설정할 때 신중히… Swap은 메모리보단 느리지만, OOM 상황에 대한 버퍼 역할을 할 수 있다.
  컨테이너를 서비스로 변환한다. 즉 Kubernetes같은 오케스트레이션으로 컨테이너를 관리, 배포하는 것이다. 서비스는 여러 컨테이너 인스턴스를 실행하고 관리하는 개념이다. 서비스 수준의 조건 및 관리를 받게
하는 것이다.


컨테이너의 메모리 엑세스를 제한하기

Docker는 하드 메모리 제한 또는 소프트 메모리
제한을 부여할 수 있습니다.


  
    하드 제한은 컨테이너가 고정된 메모리 양을 초과하지 못하게 합니다.
  
  
    소프트 제한은 컨테이너가 특정 조건만 충족된다면 필요로 하는 만큼의 메모리를 사용할 수 있게 합니다. 커널이 호스트에서 낮은 메모리 or 메모리 경합을 감지할 때와 같이.
  


위 옵션 중 하나만 쓰일 때, 또는 한 개 이상 쓰일 때는 다른 효과가 나타난다.

대부분 양의 정수 + b, k, m, g처럼 바이트, 킬로바이트, 메가바이트, 기가바이트처럼 쓰인다.


  
    
      옵션
      설명
    
  
  
    
      -m or --memory=
      컨테이너가 사용할 수 있는 메모리 최대량.
    
    
      --memory-swap=
      컨테이너가 disk로부터 사용할 수 있는 swap 메모리량. 자세히↗
    
    
      --memory-reservation
      --memory보다 작게 soft limit을 건다. 도커가 호스트로부터 메모리 경합이나 낮은 메모리를 감지할때 동작하는 수치다.
    
  


</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Huggingface 토크나이저 Padding and truncation</title>
      <url>/2023/11/28/huggingface-tokenizer-truncation/</url>
      <content type="text">huggingface에서 tokenizer를 .from_pretrained 메서드로 가져다 쓰는데, 갑자기 padding과 truncation, max_length 인자에 대해 헷갈렸다. 그래서 한 번 정리해보고자 한다.

이 글은 다음을 번역하였습니다 : 
Huggingface &amp;gt; Docs &amp;gt; Transformers &amp;gt; Padding and truncation



배치 인풋의 길이는 모두 다르기 때문에, 고정된 길이로 변환시킬 수 없는 노릇이다. Padding과 truncation 전략으로 이 문제를 해결한다.

Padding

스페셜 토큰인 padding token을 뒤쪽에 붙여서 짧은 시퀀스가 배치 내 가장 긴 시퀀스와 같은 길이를 갖게 한다. 또는 모델에 허용되는 가장 긴 길이로 만든다. 다음 값들을 갖는다.

  True or &apos;longest&apos; : 배치에서 가장 긴 길이만큼 패딩한다. 시퀀스가 하나라면 당연히 패딩하지 않는다.
  &apos;max_length&apos; : max_length 인자로 넘겨받은 길이까지 패딩한다. max_length 인자를 넘겨주지 않는 경우, 혹은 max_length=None인 경우엔 모델이 허용하는 최대 길이만큼 패딩한다. 시퀀스가 하나여도 패딩이 적용된다.
  False or &apos;do_not_pad&apos; : default값이며 패딩이 적용되지 않는다.


Truncation

긴 시퀀스를 잘라버림으로써 해결한다. 다음과 같은 인자 값을 갖는다.


  True or &apos;longest_first&apos; : max_length 인자로 받은 길이까지 자른다. 또는 max_length 인자를 넘겨주지 않거나 None으로 넘겨주는 경우, 모델이 허용하는 최대 길이까지 자른다. 당연히 토큰 단위로 자른다.
  &apos;only_second&apos; : True or &apos;longest_first&apos;와 비슷하지만, 두 문장이 pair로 입력되는 경우 두 번째 sentence만 자른다.
  &apos;only_first&apos; : 마찬가지로 두 문장이 pair로 입력되는 경우 첫 번째 sentence만 자른다.
  False of &apos;do_not_truncate&apos; : defualt 값이며, 자르지 않는다.


</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Javascript 기초</title>
      <url>/2023/11/26/javascript-basic/</url>
      <content type="text">별점도 반영하고 클릭 로그도 수집하려면 javascript를 알아야한다..! 감사하게도 Do it! 인터랙티브 웹 페이지 만들기 책에
javascript 기본 내용이 있어서 읽고 정리하게 되었다. 아직 장고와 css, html, js 사이의 데이터 이동을 시키기엔 어렵다.. 하여 또 다른 javascript 책을 파야하지 않을까 싶다!

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;ko&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;Javascript&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&amp;gt;
    &amp;lt;script&amp;gt;
        console.log(&quot;Hello world&quot;)
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;




개발자도구를 열어보면 Hello World가 출력되어있다. 웹브라우저는 HTML 파일의 위부터 순서대로 읽는다. &amp;lt;body&amp;gt; 영역이 HTML 출력을 담당하는데, &amp;lt;body&amp;gt;보다 먼저 출력되면 아직 생성되지도 않은
HTML요소를 제어할 수 없으므로 문제가 생길 것이다.

실험해보자. 그래서 script 태그에서 #title을 잡아 출력하게 하고, &amp;lt;body&amp;gt;안에는 #title을 넣어보자.

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;ko&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;Javascript&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&amp;gt;
    &amp;lt;script&amp;gt;
        const title = document.querySelector(&quot;#title&quot;);
        console.log(title);
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1 id=&quot;title&quot;&amp;gt;HELLO WORLD&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;




콘솔에서는 null이 출력된다. 자바스크립트가 실행되는 시점에서 아직 &amp;lt;body&amp;gt;부분을 읽지 못했기 때문에 #title을 잡지 못한 것이다. 호출위치를 &amp;lt;body&amp;gt;안으로 넣어보자.

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;ko&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;Javascript&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1 id=&quot;title&quot;&amp;gt;HELLO WORLD&amp;lt;/h1&amp;gt;
&amp;lt;script&amp;gt;
    const title = document.querySelector(&quot;#title&quot;);
    console.log(title);
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;




제대로 #title이 출력된다!!

이제부터는 &amp;lt;head&amp;gt;태그 안에 &amp;lt;script defer src=&quot;custom.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 처럼 외부에서 js파일을 호출하여 사용하도록 하자.
defer는 body를 해석하면서 동시에 외부 js파일을 가져오도록 한다. 그 다음 body 영역이 모두 출력된 후 외부 스크립트 파일을 실행한다.

js로 HTML 요소 선택하기

document.querySelector()

요소를 선택할 때 사용한다.


&amp;lt;section id=&quot;wrap&quot;&amp;gt;
    &amp;lt;article class=&quot;box1&quot;&amp;gt;box1&amp;lt;/article&amp;gt;
    &amp;lt;article class=&quot;box1&quot;&amp;gt;box2&amp;lt;/article&amp;gt;
    &amp;lt;article class=&quot;box1&quot;&amp;gt;box3&amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;


document.querySelector(&quot;#wrap&quot;);


body에서 id가 wrap인 요소를 찾으라는 의미다.

const frame = document.querySelector(&quot;#wrap&quot;);
console.log(frame);


frame이라는 변수에 #wrap 요소가 저장된다.



#wrap 요소가 제대로 출력되었다.

이번엔 #wrap 안에 있는 .box1을 찾아보자.

const box1 = document.querySelector(&quot;#wrap .box1&quot;);
console.log(box1);




article 속의 .box1이 잘 출력되었다.

document.querySelectorAll()

요소를 모두 선택할 때 사용한다. html은 위 예시를 그대로 쓰자.

const item = document.querySelector(&quot;#wrap article&quot;);
console.log(item);


이렇게하면 가장 첫 번째 요소만 선택한다! 즉 box1만 출력된다. 대신 이렇게 쓰자.

const items = document.querySelectorAll(&quot;#wrap article&quot;);
console.log(items);




변수엔 NodeList가 담겼다. for of 문을 사용해서 하나씩 꺼내보자.

const items = document.querySelectorAll(&quot;#wrap article&quot;);
for (let item of items) {
    console.log(item);
}


변수에는 const, let이 있다. const는 변경되지 않는 것, let은 변경되는 것이다. item은 계속 변경될 것이므로 let 변수에 담자.



하나씩 꺼내어 잘 출력했다. for문으로 사용하는 예시는 다음과 같다.

const items = document.querySelectorAll(&quot;#wrap article&quot;);
for (let i = 0; i &amp;lt; items.length; i++) {
    console.log(items[i]);
}


부모, 자식, 형제 요소 선택


&amp;lt;body&amp;gt;
&amp;lt;ul class=&quot;list&quot;&amp;gt;
    &amp;lt;li class=&quot;item1&quot;&amp;gt;box1&amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;item2&quot;&amp;gt;box2&amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;item3&quot;&amp;gt;box3&amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;item4&quot;&amp;gt;box4&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;


const list = document.querySelector(&quot;.list&quot;);
const items = list.children;

console.log(items);
console.log(items[0]);
console.log(items[1]);
console.log(items[2]);
console.log(items[3]);




.list를 선택하면 &amp;lt;ul&amp;gt;태그를 선택한 것이다. 콘솔을 보면 자식 4개가 묶여서 출력되었다. 그리고 .children으로 자식요소를 선택해 출력하면 각각의 &amp;lt;li&amp;gt;가 선택된 것을 알 수 있다.

부모 요소 선택하기

const item2 = document.querySelector(&quot;.item2&quot;);
console.log(item2.parentElement);


.parentElement를 사용하면 부모인 ul이 출력된다.

제일 가까운 상위 부모 요소 선택


&amp;lt;body&amp;gt;
&amp;lt;main&amp;gt;
    &amp;lt;section&amp;gt;
        &amp;lt;article&amp;gt;
            &amp;lt;ul&amp;gt;
                &amp;lt;li&amp;gt;list&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/article&amp;gt;
    &amp;lt;/section&amp;gt;
&amp;lt;/main&amp;gt;
&amp;lt;/body&amp;gt;


여기서 li로부터 main을 선택하고싶다면? 다음과같이 .closest를 쓰면 된다.

const li = document.querySelector(&quot;.list&quot;);
console.log(li.closest(&quot;main&quot;));


형제 요소 선택

이전 형제 : item3.previousElementSibling

다음 형제 : item3.nextElementSibling

자바스크립트로 스타일 제어


&amp;lt;body&amp;gt;
&amp;lt;article id=&quot;box&quot;&amp;gt;&amp;lt;/article&amp;gt;
&amp;lt;/body&amp;gt;


#box {
    width: 200px;
    height: 200px;
    background-color: aqua;
    border: 5px solid #000;
    transform: rotate(0deg);
}




그림과 같이 가로세로 200px의 사각형을 하나 만들었다. 그리고 다음처럼 js파일을 연결하자.

const box = document.querySelector(&quot;#box&quot;);

box.style.width = &quot;10%&quot;;
box.style.height = &quot;300px&quot;;
box.style.backgroundColor = &quot;hotpink&quot;;
box.style.border = &quot;none&quot;;
box.style.transform = &quot;rotate(10deg)&quot;




article 태그를 box 변수로 잡고, .style을 붙여 속성명을 입력하면 된다. background-color 처럼 하이픈으로 연결된 속성은 camel case로 변경해야한다. js에 예약어가 존재하기
때문이다.


  document.querySelector로 선택한 요소는 DOM 객체이다. DOM에는 HTML + 스타일 정보(style속성)도 있어서 style 속성값을 변경할 수 있다.


이벤트 연결하기

마우스 동작과 관련된 이벤트를 HTML과 연결하고 제어해보자.

클릭 이벤트 연결하기


&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;https://www.naver.com&quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;


a {
    font-size: 100px;
    color: #555;
}


const link = document.querySelector(&quot;a&quot;)

link.addEventListener(&quot;click&quot;, () =&amp;gt; {
    console.log(&quot;링크를 클릭했습니다.&quot;);
})


변수 link에 태그를 선택했다. .addEventListner()문은 (이벤트명, 전달될값=&amp;gt;실행할구문) 처럼 인자를 전달해 쓴다. 여기서는 첫 번째 인자(이벤트명) “click”을 사용했다.
두 번째 인자는 리스너인데, =&amp;gt;같은 화살표를 쓰며 이벤트가 발생할 때 응답해서 실행할 동작을 의미한다. 근데 위처럼 작성하면 클릭하자마자 네이버로 넘어가므로 링크이동을 막고 콘솔창에 출력해보도록 하자.

const link = document.querySelector(&quot;a&quot;)

link.addEventListener(&quot;click&quot;, (e) =&amp;gt; {
    e.preventDefault();
    console.log(&quot;링크를 클릭했습니다.&quot;);
})




preventDefault는 이벤트의 기본 기능을 수행하지 말라는 것이다.

여기서 e는 이벤트 객체이다.

호버 이벤트 연결하기


&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;


#box {
    width: 200px;
    height: 200px;
    background: aqua;
    margin: 100px auto;
}


const box = document.querySelector(&quot;#box&quot;);

box.addEventListener(&quot;mouseenter&quot;, () =&amp;gt; {
    box.style.backgroundColor = &quot;hotpink&quot;;
});

box.addEventListener(&quot;mouseleave&quot;, () =&amp;gt; {
    box.style.backgroundColor = &quot;aqua&quot;;
});






이벤트 mouseenter와 mouseleave를 사용했다. div 태그의 background-color 속성이 hotpink로 바뀌는 것을 볼 수 있다.

반복되는 요소에 이벤트 한꺼번에 연결하기


&amp;lt;body&amp;gt;
&amp;lt;ul class=&quot;list&quot;&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot; #&amp;gt;item1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot; #&amp;gt;item2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot; #&amp;gt;item3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot; #&amp;gt;item4&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;


const list = document.querySelectorAll(&quot;.list li&quot;);

for (let el of list) {
    el.addEventListener(&quot;click&quot;, e =&amp;gt; {
        e.preventDefault();
        console.log(e.currentTarget.innerText);
    })
}


querySelectorAll로 &amp;lt;li&amp;gt; 태그를 리스트로 묶어 list라는 변수에 담자. for of 문을 사용하여 변수 el에 저장되고 있는 반복 요소를 클릭할 때마다 해당요소를 e.currentTarget으로
선택하고 .innerText 구문을 연결해준다.
innerText 구문은 선택한 요소의 텍스트를 불러온다. 이제 각 item을 클릭하면 console에 각각 item1, item2, item3, item4가 출력된다.



클릭 이벤트가 발생할 때 숫자를 증가, 감소시키기


&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;#&quot; class=&quot;btnPlus&quot;&amp;gt;plus&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;#&quot; class=&quot;btnMinus&quot;&amp;gt;minus&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;


const btnPlus = document.querySelector(&quot;.btnPlus&quot;);
const btnMinus = document.querySelector(&quot;.btnMinus&quot;);
let num = 0; // 제어할 숫잣값을 0으로 초기화

//btnPlust를 클릭할 때마다
btnPlus.addEventListener(&quot;click&quot;, e =&amp;gt; {
    e.preventDefault();
    //num값을 1씩 증가
    num++;
    console.log(num);
})

//btnMinus를 클릭할 때마다
btnMinus.addEventListener(&quot;click&quot;, e =&amp;gt; {
    e.preventDefault();
    //num값을 1씩 감소
    num--;
    console.log(num);
})


플러스, 마이너스 버튼을 각각 btnPlus와 btnMinus에 담아두자. 변수 num을 0으로 초기화했다.
btnPlus에 클릭 이벤트가 생기면 num++ 해준다. 마찬가지로 btnMinus에는 num–를 해준다.



문자 안에 변수 삽입하기

const myName = &quot;홍길동&quot;;
console.log(`내 이름은 ${myName}입니다.`);



  콘솔문에서 백틱(`)으로 감싸줘야한다.


그리고 문자 안에서 ${변수}로 사용해주면 변수값을 사용할 수 있다.

클릭하면 좌우로 회전하는 박스 만들기


&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;#&quot; class=&quot;btnLeft&quot;&amp;gt;왼쪽으로 회전&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;#&quot; class=&quot;btnRight&quot;&amp;gt;오른쪽으로 회전&amp;lt;/a&amp;gt;
&amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;


#box {
    width: 300px;
    height: 300px;
    margin: 50px;
    background: aqua;
    transition: 0.5s;
}


가로세로 300px의 박스를 만들었습니다. transition 시간은 0.5초로 설정했습니다.

const btnLeft = document.querySelector(&quot;.btnLeft&quot;);
const btnRight = document.querySelector(&quot;.btnRight&quot;);
const box = document.querySelector(&quot;#box&quot;);
const deg = 45;
let num = 0;

btnLeft.addEventListener(&quot;click&quot;, e =&amp;gt; {
    e.preventDefault();
    num--;
    box.style.transform = `rotate(${num * deg}deg)`;
});

btnRight.addEventListener(&quot;click&quot;, e =&amp;gt; {
    e.preventDefault();
    num++;
    box.style.transform = `rotate(${num * deg}deg)`;
});


btnLeft를 클릭할때마다 num은 0에서 1, 2, … 처럼 1씩 증가한다. 반대로 btnRight를 클릭할때마다 1씩 감소한다.
btnLeft를 클릭할때마다 각도는 0, 45, 90, 135, … 처럼 45도씩 증가한다. 반대로 btnRight를 클릭할때마다 0, -45, -90, -135, …처럼 45도씩 감소한다.

주의할 점은 rotate(${num * deg})를 백틱(`)으로 감싸야한다는 것이다.





클릭할때마다 45도만큼 회전한다.

자바스크립트로 클래스 제어하기

자바스크립트로 HTML 스타일을 변경하는건 추천되지 않는다. CSS 파일이 우선순위에서 무시되기 때문이다. 그러니 CSS에서 스타일을 설정해주고, 자바스크립트는 클래스 이름만 추가/제거하도록 해보자.


&amp;lt;body&amp;gt;
&amp;lt;section id=&quot;wrap&quot;&amp;gt;
    &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;/body&amp;gt;


#wrap {
    width: 500px;
    height: 500px;
    border: 1px solid #000;
    padding: 100px;
    box-sizing: border-box;
    margin: 100px auto;
}

#wrap article {
    width: 100%;
    height: 100%;
    background: aqua;
    transition: 1s;
}




일단 body부터 살펴보자. 왠지모르게 가장 위부터가 아니지만, 이는 section에게 margin(바깥여백)을 준만큼 띄워졌기 때문이다. section 태그를 살펴보자.



가로세로 500px의 검정(#000)테두리 박스이다. 근데 margin을 상하 100px을 줬기 때문에 body 영역을 상하로 넘어섰고, 좌우는 auto를 줬기 때문에 중앙에 배치되었다.
또한 padding을 100px 줬기 때문에 내부는 300px 300px이 됐을 것이다.
또한 box-sizing: border-box 옵션을 줬으므로 500 x 500을 해치지 않고(?), 변형없이(?) 500 X 500의 검정 박스가 생겼다. 이제 article을 보면..



가로세로 부모의 100%를 쓴다고 해도 300px X 300px 이 되었다.

const wrap = document.querySelector(&quot;#wrap&quot;);
const box = wrap.querySelector(&quot;article&quot;);

wrap.addEventListener(&quot;click&quot;, () =&amp;gt; {
    box.style.backgroundColor = &quot;hotpink&quot;;
});


wrap을 변수에 저장하고, 다시 wrap을 이용해 querySelector를 사용해 article 자식을 선택한다.
wrap을 클릭하면 article의 background-color를 hotpink로 바꾼다.



클릭하면 색깔이 1초동안 hotpink로 바뀐다. article 태그의 style 속성에 “background-color:hotpink”가 추가되었다.
그런데 이렇게 태그에 인라인 형태로 삽입된 스타일 구문은 우선순위가 매우 높아서 기존 CSS를 무시하게 된다. 그러니 클래스명을 추가해서 제어해보자.

#wrap.on article {
    background: hotpink;
}


wrap.addEventListener(&quot;click&quot;, () =&amp;gt; {
    wrap.classList.add(&quot;on&quot;);
});


클릭하면 on 클래스를 추가하고, 클래스에 on이 추가되면 article의 배경색이 hotpink로 바뀌도록 합니다.



클릭하면 #wrap 요소에 “on”이라는 요소가 추가됐다. 스타일을 강제로 바꾸지 않으면서 부모 요소에 “on”만 추가되어 변경되도록 했다.
다시 클릭했을때 색이 돌아오도록 하려면 클릭상태를 저장했다가 “on”을 제거하면 된다.

wrap.addEventListener(&quot;click&quot;, () =&amp;gt; {
    let isOn = wrap.classList.contains(&quot;on&quot;);
    console.log(isOn);

    if (isOn) {
        wrap.classList.remove(&quot;on&quot;);
    } else {
        wrap.classList.add(&quot;on&quot;);
    }
});


또는 삼항연산자를 이용해서 다음과 같이 쓸 수 있다.

(isOn) ? wrap.classList.remove(&quot;on&quot;) : wrap.classList.add(&quot;on&quot;);




클릭했다가 다시 클릭하면 inOn은 False로 바뀌며 aqua로 돌아온다.

이처럼, HTML이 이미 출력되었다 하더라도 이벤트가 발생할때마다 언제든지 그 요소를 동적으로 변경할 수 있다!

위 기능은 classList.toggle() 기능을 쓰면 효율적으로 구현할 수 있다.

wrap.addEventListener(&quot;click&quot;, () =&amp;gt; {
    wrap.classList.toggle(&quot;on&quot;)
})


선택한 요소에 클래스가 있으면 제거해주고 없으면 추가해주라는 의미이다.



함수를 활용하여 코드 패키징하기와 속성값 활용하기는 다음에 정리.

</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>CSS 기초 - 인터랙티브</title>
      <url>/2023/11/22/css-basic2/</url>
      <content type="text">두 번째 시간…이번에는 trasform, transition 등으로 동적으로 움직이는 기능을 구현해보자. 또 flex라는 것을 이용해 자식 요소의 배치 방법을 지정해보자.
이 글은 Do it! 인터랙티브 웹 페이지 만들기 책을 읽고 공부한 내용입니다.

transform을 배워보자


&amp;lt;body&amp;gt;
&amp;lt;section&amp;gt;
    &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;section&amp;gt;
    &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;section&amp;gt;
    &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;section&amp;gt;
    &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;/body&amp;gt;


section을 4개 만들고 자식태그로 article을 넣어보자.

section {
    width: 200px;
    height: 200px;
    border: 1px solid #000;
    float: left;
    margin: 50px;
}

section article {
    width: 100%;
    height: 100%;
    background: blue;
    opacity: 0.3;
}

section:nth-of-type(1) article {
    transform: scale(1.3);
}

section:nth-of-type(2) article {
    transform: skewX(20deg);
}

section:nth-of-type(3) article {
    transform: translateY(50px);
}

section:nth-of-type(4) article {
    transform: rotate(45deg);
}




딱 봐도 효과는 알 수 있다. 각각 확대 또는 축소, 기울기, 이동, 회전이 적용된다.

이젠 사용자 행동에 반응하도록 만들어보자!! transition을 사용하면 된다.

transition - 가장 재미있단다

&amp;lt;body&amp;gt;
&amp;lt;section&amp;gt;
    &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;/body&amp;gt;


section {
    width: 200px;
    height: 200px;
    border: 1px solid #000;
    float: left;
    margin: 50px;
    perspective: 800px;
}
.section::after {
    content: &apos;&apos;;
    display: block;
    clear: both;
}

section article {
    width: 100%;
    height: 100%;
    background: blue;
    opacity: 0.3;
    transform: rotateY(10deg);  # 시작 각도 (아무것도 안했을 때)
    transition-property: transform opacity;
    transition-duration: .3s;
    transition-delay: 0s;
    transition-timing-function: cubic-bezier(.8, -0.1, .58, 1.39);
}
article:hover {
    transform: rotateY(60deg);
    background: red;
}






마우스를 올려놓으면 0.3초 안에, 딜레이 없이 바로, 10도에서 시작해 60도까지 Y축으로 회전하며, 가속도는 transition-timing-function에 입력한대로 회전한다.
perspective를 설정하니 800px만큼 멀리서 보는 것처럼 약간 회전해있다.

cubic-bezier는 쉽게 만들어주는 사이트에서 참고하면 된다고 한다. –&amp;gt; cubic-bezier.com

화면 너비에 따라 웹페이지 디자인 변경하기

미디어 쿼리를 이용하면 웹 브라우저의 너비를 인식하여 css를 다르게 설정할 수 있다. 예를 들어 너비가 1000px일 때 실행할 css는 다음과 같다.

@media screen and (max-width: 1000px){
    실행할 css
}

웹브라우저의 폭이 0~1000px일 때 실행할 css 구문을 우선 적용한다.

예시를 살펴보자.

&amp;lt;body&amp;gt;
    &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
&amp;lt;/body&amp;gt;


article{
    width: 200px;
    height: 200px;
    background: pink;
    margin: 100px auto;
}


이 상태에서는 다음과 같이 정가운데에 200 X 200의 핑크 사각형이 위치해있다.



이제 미디어 쿼리를 적용해보자. 웹브라우저 너비가 900px 이하일 때 article 요소의 배경색을 orange로 입력해보자.

@media screen and (max-width: 900px){
    article{
        background: orange;
    }
}


이렇게 하면 이전 article이 핑크색이었더라도 미디어 쿼리의 최대 너비인 max-width값을 900px로 지정했으므로 이 구간에서는 핑크를 무시하고 orange를 우선 적용한다.



너비를 900 이하로 바꾸니 오랜지색으로 변경되었다. 400 이하일 땐 aqua로 바꿀 수도 있을 것이다.

flex

display - 자식 요소의 배치 방법 지정

원래 float은 레이아웃이 아닌 텍스트와 이미지를 좌우로 배치하기 위해 사용한다. 과거에는 float을 많이 사용했지만 HTML5부터 flex 방식으로 편하게 레이아웃을 배치할 수 있다고 한다.

&amp;lt;body&amp;gt;
    &amp;lt;main&amp;gt;
        &amp;lt;section&amp;gt;
            &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
            &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
            &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
            &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
            &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
        &amp;lt;/section&amp;gt;
    &amp;lt;/main&amp;gt;
&amp;lt;/body&amp;gt;


* {
    margin: 0px;
    padding: 0px;
}
main {
    width: 100%;
    height: 100vh;
    background: lightcyan;
}
section {
    border: 10px solid blue;
}
section article{
    width: 100px;
    height: 100px;
    background: aqua;
    border: 1px solid #000;
}




main은 body를 꽉 채우는 영역이 된다. section은 자식을 감싸고 있고, 각 article은 100 X 100의 사각형 영역이 된다. 이제 부모인 section에 flex를 적용해보자.

section {
    border: 10px solid blue;
    display: flex;
}




display: flex는 자신의 블록 속성을 유지하면서 자식 요소에 flex 환경을 설정해준다. 자식들인 article이 가로로 배치되었다. 
이 때 부모인 section도 그대로 블록 요소 특징을 유지하므로 너빗값이 100%로 유지된다.

이번에는 inline-flex로 바꿔보자.



inline-flex는 자신을 인라인 속성으로 변경하면서 자식 요소에 flex 환경을 설정한다. 그래서 section이 인라인 속성으로 변경되어 자식 요소의 전체 너빗값만큼 크기가 달라진다.

flex-direction

section {
    border: 10px solid blue;
    display: inline-flex;
    flex-direction: column;
}



flex-direction으로 정렬 방향을 설정할 수 있다. 설정하지 않으면 기본 값은 row(가로)로 설정되고 column을 사용하면 세로로 정렬된다.

flex-wrap : 자식에 줄바꿈 적용

float을 사용했을 때는 자식의 너빗값 합이 부모의 너빗값을 넘어가면 자동으로 줄바꿈 됐었다. 
하지만 flex는 flex-wrap을 설정해야 줄바꿈을 할 수 있다.

section {
    width: 100%;
    border: 10px solid blue;
    box-sizing: border-box;
    display: flex;
    flex-direction: row;
}




box-sizing: border-box는 안쪽여백(padding)에서 나왔었는데, 그냥 padding을 쓰면 전체 박스 크기가 커지지만 원래 크기로 유지하고 안쪽 여백을 추가할 때 썼었다.

암튼 이대로 브라우저 창을 줄이면 같은 비율로 줄어든다. flex-wrap을 추가해보자.

section {
    width: 100%;
    border: 10px solid blue;
    box-sizing: border-box;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
}




자식요소인 article의 너빗값이 그대로 유지되면서 줄바꿈된다.

flex-flow : flex-direction, flex-wrap 한꺼번에 적용

flex-flow를 사용하면 flex-direction, flex-wrap 속성을 한번에 적용할 수 있다.

section {
    width: 100%;
    border: 10px solid blue;
    box-sizing: border-box;
    display: flex;
    flex-flow: row wrap;
}


자식요소 정렬하기

flex의 핵심 기능은 자식 요소를 어떻게 정렬하는가이다. 자식요소는 justify-content나 align-content, align-items 속성을 사용해 정렬할 수 있다.

justify-content

section {
    width: 100%;
    height: 100%;
    border: 10px solid blue;
    box-sizing: border-box;
    display: flex;
    flex-flow: row wrap;
    justify-content: flex-start;
}



flex-start는 justify-content의 기본 값이다. 가장 위쪽 article 탭이 가장 왼쪽부터 시작한다.
flex-end로 설정해보자.



종료 방향인 오른쪽으로 정렬된다. center로 해보자.



가운데로 정렬된다.

</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>CSS 기초</title>
      <url>/2023/11/22/css-basic/</url>
      <content type="text">추천시스템 페이지를 만드는 중 별점이 이상하게 표시되는 현상이 있었다… 책 Do it! 인터랙티브 웹 페이지 만들기에 나오는 템플릿 그대로 사용하다보니 이런 문제가 생겨도 해결하지 못하여 CSS 완전 쌩기초부터
정리해보려한다. 이 글은 Do it! 인터랙티브 웹 페이지 만들기 책을 읽고 공부한 내용입니다.



위 사진의 html코드는 다음과 같다.


&amp;lt;body&amp;gt;
&amp;lt;main&amp;gt;
    &amp;lt;section&amp;gt;
        
    &amp;lt;/section&amp;gt;
&amp;lt;/main&amp;gt;
&amp;lt;/body&amp;gt;


배경이 되는 회색 별은 &amp;lt;p&amp;gt;태그 바로 아래의 별 다섯개이고, 노란색으로 채워지는 별은 span.rating_star태그이다.
CSS 코드를 여기 적기엔 너무 길기 때문에 CSS를 공부하면서 왜 저렇게 되는지 알아보자..

아참 위 html 코드의 출처는 [JavaScript] 별점 드래그 기능 만들기이다. (감사합니다ㅠ)



전체 선택자

* {
    border: 1px solid red;
}


body 태그를 포함해 태그 전체를 선택할 수 있다.

태그 선택자

특정 태그를 선택한다.

h1 {
    border: 1px solid red;
}

h2 {
    border: 1px solid blue;
}


자손 선택자

자식과 하위요소를 포함해 그 하위에 있는 모든 요소를 선택한다.

p strong {
    border: 1px solid blue;
}


자식 선택자

직계 자식요소만 선택한다.

ul &amp;gt; li {
    border: 1px solid blue;
}


속성 선택자

아래와 같은 HTML이 있다고 하자.


&amp;lt;body&amp;gt;
&amp;lt;form&amp;gt;
    &amp;lt;input type=&quot;text&quot;&amp;gt;
    &amp;lt;input type=&quot;password&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;


form 태그 안에 input 태그를 2개 작성하고 type 속성을 각각 지정하자.

input[type=&quot;text&quot;] {
    border: 1px solid blue;
}

input[type=&quot;password&quot;] {
    border: 1px solid red;
}




그럼 결과는 다음과 같다. input 태그의 type 속성마다 각각 적용된다.

가상 선택자

가상 선택자(virtual selector)는 특정 조건이 충족될 때 실행되도록 한다. 예를 들어 다음과 같은 HTML과 CSS가 있다고 하자.


&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;HELLO&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;


h1 {
    border: 1px solid blue;
}

h1:hover {
    border: 2px dashed red;
}


두번째 요소에는 h1에 :hover라는 가상 선택자를 붙였다.



마우스를 올려놓기 전엔 파란색 solid 선이다.



마우스를 올려놓으면 빨간색 dashed 선으로 바뀐다.

이번엔 가상선택자 :before와 :after에 대해 알아보자.

h1:before {
    content: &quot;before content&quot;;
    color: blue;
}

h1:after {
    content: &quot;after content&quot;;
    color: red;
}




그림처럼 :before와 :after는 ‘content’에 입력한 글자가 HELLO 앞뒤에 나타난다. 개발자도구에서 확인해보면 ::before와 ::after라는 가상의 요소가 생성되었다. HTML 파일에 입력하지
않아도 CSS파일에서 입력한 콘텐츠가 생기는 것이다.

클래스 선택자와 아이디 선택자

는 각각 .과 #를 사용하면 되니 넘어가자.

폰트 굵기

normal과 bold 두 가지가 있다.

h1 {
    font-weight: normal; /*h1의 기본 굵기를 제거하고 normal을 적용한다.*/
}

p span {
    font-weight: bold;
}


폰트 크기 바꾸기

웹페이지는 보통 픽셀로 구성되기 때문에 px를 주로 쓰지만 가끔 rem이나 em을 쓴다.
rem은 최상위 부모인 &amp;lt;html&amp;gt;태그를 기준으로 폰트 크기를 설정한다. em은 부모 요소를 기준으로 폰트 크기를 설정한다.

픽셀은 다음과 같이 숫자로 설정한다.

articel h1 {
    font-size: 60px;
}


rem 사용할 땐 다음과 같다.

html {
    font-size: 16px;
}

article h1 {
    font-size: 3rem;
}


최상위 요소인 html의 폰트 크기를 16px로 설정하고 h1태그는 3rem으로 설정했다. 즉 html요소 기준으로 3배 키우라는 뜻이다.

rem이 나온 후 em은 잘 쓰지 않는다고 한다. 부모태그 기준으로 설정된다.

폰트 모양 바꾸기

font-family 속성을 사용한다.


&amp;lt;body&amp;gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;FONT FAMILY&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Serif&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;


ul li {
    font-size: 40px;
}

ul li:nth-of-type(1) {
    font-family: &quot;돋움&quot;
}

ul li:nth-of-type(2) {
    font-family: &quot;serif&quot;
}


구글 웹 폰트를 사용하려면 fonts.google.com으로 접속해서 원하는 폰트의 웹폰트 코드와 font-family를 가져와 사용하면 된다.


&amp;lt;body&amp;gt;
&amp;lt;p id=&quot;txt&quot;&amp;gt;LOREM IPSUM&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;


@charset &quot;utf-8&quot;;
@import url(url을

넣는다
)
;

p#txt {
    font-size: 100px;
    font-family: &apos;Monoton&apos;, &apos;cursive&apos;
}


폰트 색상 바꾸기

영문명, 또는 #000000같은 16진수, 또는 rgb(0, 0, 0)같은 RGB로 입력한다.


&amp;lt;body&amp;gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;색상명 표기법&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;16진수 표기법&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;RGB 표기법&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;


li:nth-of-type(1) {
    color: red;
}

li:nth-of-type(2) {
    color: #ff0000;
}

li:nth-of-type(3) {
    color: rgb(255, 0, 0);
}


셋 다 빨간색을 의미한다.

텍스트 줄 간격 바꾸기

font-size는 텍스트 자체의 높이를 의미한다. line-height는 줄 간격 전체 높잇값을 나타낸다. 실수 값으로 쓸 수도 있고, 픽셀값으로 쓸 수도 있다.


&amp;lt;body&amp;gt;
&amp;lt;p class=&quot;text1&quot;&amp;gt;
    Hello. This is..
&amp;lt;/p&amp;gt;
&amp;lt;p class=&quot;text2&quot;&amp;gt;
    Hello. This is..
&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;


.text1 {
    font-size: 20px;
    line-height: 40px;
    border: 1px solid red;
}

.text2 {
    font-size: 20px;
    line-height: 1.5;
    border: 1px solid blue;
}






실수 1.5로 설정한 .text2의 경우 폰트 크기 20px을 기준으로 1.5배로 설정되었다.

텍스트 정렬 방향 지정하기

text-align이라는 속성을 사용하며 left, right, center, justifiy(양쪽정렬)이 있다.

텍스트 자간 지정하기

letter-spacing이란 속성을 사용하며 px로 설정한다.

너비와 높이 지정하기

태그 영역의 크기는 width, height 속성을 사용함으로써 정의되며, px, %(부모태그 기준), vw(웹브라우저 너비 기준 백분율), vh(웹브라우저 높이 기준 백분율)을 사용한다.


&amp;lt;body&amp;gt;
&amp;lt;article&amp;gt;
    width, height 모두 100px로 했을 때
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    width, height 모두 20%로 했을 때
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    width, height 모두 10vw로 했을 때
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    width, height 모두 10vh로 했을 때
&amp;lt;/article&amp;gt;
&amp;lt;/body&amp;gt;


article {
    border: 1px solid red;
}

article:nth-of-type(1) {
    width: 100px;
    height: 100px;
}

article:nth-of-type(2) {
    width: 20%;
    height: 20%;
}

article:nth-of-type(3) {
    width: 10vw;
    height: 10vw;
}

article:nth-of-type(4) {
    width: 10vh;
    height: 10vh;
}


px로 지정하면 웹브라우저 크기가 달라져도 영역 넓이가 변하지 않는 한편, %로 지정하면 웹브라우저 크기가 달라졌을 때 부모 태그인 &amp;lt;body&amp;gt;태그 기준으로 너빗값이 변한다.





그러나 body태그는 height가 변하지 않는다! 그래서 %를 사용한다면 높이는 변하지 않는다.

바깥쪽 여백 지정하기

margin 속성을 사용해 지정한다. px, %(부모 태그 기준), vw(웹브라우저 너비 기준), vh(웹브라우저 높이 기준)을 사용한다.


&amp;lt;body&amp;gt;
&amp;lt;article&amp;gt;
    margin: 20px (상하좌우)
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    margin: 20px 50px (상하, 좌우)
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    margin: 20px auto (상하, 좌우중앙)
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    margin: 20px auto 40px (상, 좌우중앙, 하)
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    margin: 0px 10px 20px 30px (상, 우, 하, 좌)
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    margin-left: 20px (좌)
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    margin-right: 20px (우)
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    margin-top: 20px (상)
&amp;lt;/article&amp;gt;
&amp;lt;article&amp;gt;
    margin-bottom: 20px (하)
&amp;lt;/article&amp;gt;
&amp;lt;/body&amp;gt;


article {
    width: 150px;
    height: 40px;
    border: 1px solid red;
}

article:nth-of-type(1) {
    margin: 20px;
}

article:nth-of-type(2) {
    margin: 20px 50px;
}

article:nth-of-type(3) {
    margin: 20px auto;
}

article:nth-of-type(4) {
    margin: 20px auto 40px;
}

article:nth-of-type(5) {
    margin: 0px 10px 20px 30px;
}

article:nth-of-type(6) {
    margin-left: 20px;
}

article:nth-of-type(7) {
    margin-right: 20px;
}

article:nth-of-type(8) {
    margin-top: 20px;
}

article:nth-of-type(9) {
    margin-bottom: 20px;
}




일단 body 영역부터 확인하고 들어가보자.



실제론 상하 여백만 지정하고 좌우 여백은 중앙에 배치하도록 하는 방법을 가장 많이 사용한다고 한다.

안쪽 여백 지정하기

안쪽 여백은 padding 속성을 사용하며, 사용법은 px, %, vw, vh로 margin과 사용법이 같다.


&amp;lt;body&amp;gt;
  &amp;lt;article&amp;gt;
      box1
  &amp;lt;/article&amp;gt;
  &amp;lt;article&amp;gt;
      box2
  &amp;lt;/article&amp;gt;
&amp;lt;/body&amp;gt;


article {
    width: 100px;
    height: 100px;
    border: 1px solid red;
}

article:nth-of-type(1) {
    padding: 0px;
}

article:nth-of-type(2) {
    padding: 30px;
}




body 영역부터 확인해보자.



일단 box1과 box2는 동일하게 width 100, height 100이다.

box1은 안쪽여백(padding)을 0으로 줬기 때문에 box1이라는 텍스트가 박스 가장자리에 붙어있다.



그런데 box2는 안쪽여백에 30px을 주었기 때문에 box2라는 텍스트가 여백 안쪽에 위치한다. 박스 크기가 커진 것이다. 이처럼 padding은 기존 요소 크기에 안쪽 여백을 추가해준다. 결과적으로 box2의
너빗값과 높잇값은 160px이 된다.

그럼 기존 박스 크기는 유지하고 안쪽 여백만 있게 하려면? width와 height를 새로 작게 지정해줘서 padding까지 더한 값이 100이 되게 만들수도 있다.
하지만 box-sizing 속성을 이용하면 기존 너빗값과 높잇값을 자동으로 포함시킬 수 있다.

article {
    width: 100px;
    height: 100px;
    border: 1px solid red;
}

article:nth-of-type(1) {
    padding: 0px;
}

article:nth-of-type(2) {
    padding: 30px;
    box-sizing: border-box;
}


box-sizing: border-box 속성만 추가하면 기존 박스 크기를 유지하면서 여백을 지정할 수 있다.



100 x 100은 유지하면서 안쪽 여백인 padding 30px이 추가됐다.

블록 요소와 인라인 요소 태그

태그의 크기 및 테두리 등을 지정할 때는 해당 태그가 블록 요소인지 인라인 요소인지에 따라 다르게 적용된다.

블록 요소 : 웹페이지 영역을 구분하는 레이아웃과 관련된다. h1~h6, p, ol, ul, dl, div, header, footer, section, article, aside, nav 등. 줄을 자동으로
바꾼다. 넓이와 높이를 지정할 수 있다. 너비를 지정하지 않을 시 부모의 너빗값을 100% 상속받는다. 블록요소와 인라인요소 모두 묶을 수 있다.

인라인 요소 : 글의 서식과 관련된다. strong, em, a, span 등. 자동 줄바꿈 X, 옆으로 나열된다. 너비와 높이를 지정할 수 없다. 텍스트의 크기 자체가 해당 요소의 크기가 된다. 인라인 요소만 묶을
수 있다.


&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;
    블록 요소 태그는 자동 줄 바꿈 됩니다. 현재 이 글은 p 태그입니다.
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
        &amp;lt;span&amp;gt;
            &amp;lt;strong&amp;gt;인라인 요소 태그&amp;lt;/strong&amp;gt;들은 &amp;lt;em&amp;gt;좌우로&amp;lt;/em&amp;gt; 배치됩니다.
        &amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;


p {
    border: 1px solid red;
}

strong, em {
    border: 1px solid blue;
}




블록 요소인 p태그에 width와 height를 설정하지 않아서 부모태그인 body태그의 width와 height를 상속받았다. 그리고 빨간색 테두리를 갖고있으며, 자기들 p태그끼리 자동 줄바꿈이 됐다. 반면 인라인
요소인 strong과 em태그는 줄바꿈되지 않았다. 그리고 border를 보면 딱 텍스트만큼만 생긴걸 알 수 있다.

블록요소와 인라인 요소의 크기를 지정해보자.

p {
    border: 1px solid red;
    height: 100px;
}

strong, em {
    border: 1px solid blue;
    height: 50px;
}


각각 height를 100px, 50px씩 지정해보았다.



p태그는 height가 제대로 적용되어 빨간색 박스의 높이가 커졌다. 그런데 strong, em태그에는 적용되지 않았다.

하지만 강제로 적용해야 할때는 display: inline-block이라는 속성을 추가하여 인라인, 블록 요소의 속성을 모두 사용하겠다고 하면 된다.

p {
    border: 1px solid red;
    height: 100px;
}

strong, em {
    border: 1px solid blue;
    height: 50px;
    display: inline-block;
}




strong, em태그에도 height가 적용되었다.

인라인을 블록 요소로 강제 변환도 가능하다. display: block을 쓰면 된다. 만약 위의 strong, em태그에 이 display: block를 쓰면 어떻게 될까? 아마 height값이 적용될거고, 자동
줄바꿈이 될거고, 크기는 텍스트 크기가 아니라 body의 width와 height를 상속받을 것이다.

p {
    border: 1px solid red;
    height: 100px;
}

strong, em {
    border: 1px solid blue;
    height: 50px;
    display: block;
}




심지어 ‘좌우로’의 em태그 크기는 두 번째 p태그를 넘어버렸다.



배경색 지정하기

backgound-color 속성을 사용한다. 영문명, rgb(0, 0, 0), #000000(16진수)같은 표현을 사용한다.


&amp;lt;body&amp;gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;#000&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;#111&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;#222&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;#333&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;#444&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;#555&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;


li {
    color: #000
}

li:nth-of-type(1) {
    background-color: #000
}

li:nth-of-type(2) {
    background-color: #111
}

li:nth-of-type(3) {
    background-color: #222
}

li:nth-of-type(4) {
    background-color: #333
}

li:nth-of-type(5) {
    background-color: #444
}

li:nth-of-type(6) {
    background-color: #555
}




배경 이미지 삽입하기


  background-image : 이미지의 url
  background-repeat : repeat, repeat-x, repeat-y, no-repeat
  background-position : 가로축, 세로축 위치 지정. ‘center, center’로 지정하면 좌우 중앙, 상하 중앙이므로 정중앙에 위치한다.
  background-size : 배경이미지의 크기. contain으로 지정하면 이미지 비율은 유지시키면서 태그 안 영역을 비율에 맞게 가득 채운다. cover로 지정하면 이미지가 잘리더라도 영역을 꽉차게 가득
채운다.
  background-attachment : 배경이미지가 움직이지 않게 고정한다. fixed로 지정하면 어느 태그에 종속되어있든 상관없이 무조건 웹브라우저 기준으로 고정된다.



&amp;lt;body&amp;gt;
&amp;lt;section&amp;gt;
    &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
    &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;/body&amp;gt;


section {
    width: 90vw;
    height: 90vh;
    margin: 4vh auto;
    border: 1px solid #000;
}

section article {
    width: 100%;
    height: 50%;
    background-repeat: no-repeat;
    background-position: center center;
}

section article:nth-of-type(1) {
    background-image: url(&apos;../img/car1.jpg&apos;);
}

section article:nth-of-type(2) {
    background-image: url(&apos;../img/car2.jpg&apos;);
}






section 태그를 살펴볼까? width와 height를 vw, vh로 했기 때문에 웹브라우저의 크기가 변해도 비율을 유지한다. 각 이미지가 각 article 태그 안에 정중앙에 위치하고 있다. 만약
article의 height를 80%로 하면 어떻게 될까? 이미지가 section 범위를 넘어버린다.



article에 background-attachment: fixed 속성을 넣어볼까? 그럼 article 태그는 어느 태그에 종속되어있든 상관하지 않고, 무조건 웹브라우저 기준으로 고정된다.





레이아웃 구성하기

블록 요소를 이용하여 집안을 거실, 주방, 서재 등으로 나누듯이 웹페이지의 레이아웃을 구성해보자.

웹페이지의 레이아웃을 나누기 전에 css를 초기화해야 하는데, 그 이유는 모든 태그엔 기본 여백, 폰트가 설정돼있어서 원하는 값으로 조정하려면 불편하기 때문이다.
그래서 여백 및 크기 등을 미리 초기화해야한다. 초기화하지 않으면 어떤 문제가 있는지 확인해보자.


&amp;lt;body&amp;gt;
&amp;lt;article&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;list1&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;list2&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;a href=&quot;#&quot;&amp;gt;link&amp;lt;/a&amp;gt;
&amp;lt;/article&amp;gt;
&amp;lt;/body&amp;gt;


article {
    border: 1px solid red;
}

ul li {
    border: 1px solid blue;
}




ul태그를 볼까? 상위 태그인 section에 이미 기본 여백 설정되어있고 li 태그엔 점(dot)이 기본적으로 설정되어 있어, li태그를 직접 조정하더라도 원하는대로 만들어지기 쉽지않다.
link에는 기본적으로 밑줄이 들어가있다. 초기화를 해보자.

* {
    margin: 0px;
    padding: 0px;
}

ul, ol {
    list-style: none;
}

a {
    text-decoration: none;
}

article {
    border: 1px solid red;
}

ul li {
    border: 1px solid blue;
}




전체 선택자 *를 이용해 모든 태그의 바깥쪽, 안쪽 여백을 0px로 만들고, ul, ol요소의 기본인 점을 없앤다. 그리고 a 태그의 밑줄을 제거한다.

float - 블록 요소를 좌우로 배치하기

블록 요소의 특징은 뭐였을까? 레이아웃 배치때 사용되며 자동 줄바꿈이 적용되어 한줄에 한 태그만 사용된다. 한 줄에 2개 이상의 블록 요소를 배치하려면 float 속성을 사용해야한다.
단어 그대로, 블록 요소를 그대로 띄워(?) 좌우로 배치한다. left, right 값을 사용하면 된다.


&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;wrap&quot;&amp;gt;
    &amp;lt;section class=&quot;left&quot;&amp;gt;&amp;lt;/section&amp;gt;
    &amp;lt;section class=&quot;right&quot;&amp;gt;&amp;lt;/section&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;


.wrap {
    width: 800px;
    margin: 100px;
    border: 5px solid black;
}

.wrap .left {
    width: 300px;
    height: 400px;
    background-color: pink;
}

.wrap .right {
    width: 400px;
    height: 400px;
    background-color: lightblue;
}




일단 float를 적용하기 전을 볼까? div.wrap 태그를 800px의 넓이를 주고 중앙에 위치시킨다. 자식인 section.left와 section.right에는 너비를 300px, 400px로 준다.
일반적으로, 블록 요소 안에서 자식요소를 넣으면 부모의 블록에는 높이를 지정하지 않는다. 왜냐면 자식들의 높이를 인지하여 감싸기 때문이다.

이제 section.left와 section.right에 float:left를 추가해보자.

.wrap {
    width: 800px;
    margin: 100px;
    border: 5px solid black;
}

.wrap .left {
    width: 300px;
    height: 400px;
    background-color: pink;
    float: left;
}

.wrap .right {
    width: 400px;
    height: 400px;
    background-color: lightblue;
    float: left;
}




.wrap이 자식 요소의 높잇값을 인식하지 못했다! 테두리를 감싸지 못했다. 블록 요소에 float를 적용시키면 부모 요소는 자식 요소의 높이를 인식하지 못한다.
그렇다면 자식 요소에 float가 적용되어도 부모 요소가 자식 요소의 높잇값을 인식할 수 있도록 해보자.

.wrap {
    width: 800px;
    margin: 100px;
    border: 5px solid black;
}

.wrap::after {
    content: &apos;&apos;;
    display: block;
    clear: both;
}

.wrap .left {
    width: 300px;
    height: 400px;
    background-color: pink;
    float: left;
}

.wrap .right {
    width: 400px;
    height: 400px;
    background-color: lightblue;
    float: left;
}




가상선택자 ::after를 생성하고 content는 빈 문자를, div.wrap을 block 속성으로 강제로 변경해버립니다. div는 이미 블록이니까 div가 아니라 ::after를 블록으로 변경한다는것 같습니다.
마지막으로 clear: both를 하면 float영향을 해제할 수 있다고 합니다.

position - 요소를 자유롭게 배치하기

position은 특정 영역 안에서 위치 조절을 더욱 자유롭게, 순서와 상관없이 화면에 가로세로 좌푯값을 직접 설정하여 배치할 수 있다.

값으로는 다음 값을 사용할 수 있다.


  relative : 원래 위치를 기준으로 상대 위치를 지정
  absolute : 부모 요소의 특정 구간을 기준으로 절대 위치를 지정
  fixed : 웹브라우저를 기준으로 절대 위치를 지정



&amp;lt;body&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;section&amp;gt;&amp;lt;/section&amp;gt;
    &amp;lt;section&amp;gt;&amp;lt;/section&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;


section {
    width: 600px;
    height: 200px;
}

section:nth-of-type(1) {
    background-color: pink;
}

section:nth-of-type(2) {
    background-color: lightblue;
    position: relative;
    top: -100px;
    left: 100px;
}




seection 중 두번째만 position: relative를 적용시키고 좌푯값을 입력했다. top은 -100을 입력했기 때문에 오히려 위로 올라가버렸다. 그리고 left는 해당 방향에서 바라보는 쪽으로, 즉
오른쪽으로 100px만큼 이동해버렸다.
left, right, top, bottom으로 지정할 수 있다. 이제 abolute를 적용해보자.


&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;wrap&quot;&amp;gt;
    &amp;lt;div class=&quot;left&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;right&quot;&amp;gt;
        &amp;lt;p class=&quot;box&quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;bottom&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;


.wrap {
    width: 800px;
    border: 5px solid black;
    margin: 50px auto;
}

.wrap::after {
    content: &apos;&apos;;
    display: block;
    clear: both;
}

.wrap .left {
    width: 400px;
    height: 400px;
    background-color: lightgreen;
    float: left;
}

.wrap .right {
    width: 400px;
    height: 400px;
    background-color: lightblue;
    float: left;
}

.wrap .right .box {
    width: 100px;
    height: 100px;
    background-color: red;
}

.wrap .bottom {
    width: 800px;
    height: 100px;
    background-color: pink;
    float: left;
}


일단 .left, .right, .bottom 요소를 배치했는데 각각 float 속성을 주어 가로로 배치했다. 이 때 wrap에는 ::after 가상 선택자를 줘서 float 영향을 해제한다.
wrap은 자식 요소들의 높이를 인식할 수 있다.



이 float가 살짝 어려운데… 부모 요소는 현재 float가 해제된 상태다. 이 때 자식 요소 중 하나라도 float가 있다면, 모든 형제가 float를 설정해야 해당 요소의 높잇값을 인식한다고 한다.
지금은 bottom이 오른쪽에 공간이 없어서 자연스럽게 아래로 내려간 것이라고 한다.

다시 bottom에 float를 적용하고 가자. 현재 .right 안에 p가 있고, 색깔은 빨간색이다.
p 태그를 오른쪽으로 20px, 아래로 30px 이동시켜보자. 이 때 padding과 margin으로 설정하려면 매우 불편하다. absolute를 사용해보자.

.wrap .right .box {
    width: 100px;
    height: 100px;
    background-color: red;
    position: absolute;
    right: 100px;
    bottom: 30px;
}




p는 이제 부모(또는 조상) 요소 중 position이 적용된 요소를 기준으로 설정된다. 즉, 현재는 부모인 div.wrap에 poision이 없이 때문에 최상위 태그인 body 기준으로 오른쪽에서 100px
떨어진, 아래에서 30px 떨어진 곳에 위치한다.
현재는 부모, 조상 전부 뒤져봐도 Position 값이 없는 경우인데, 이때는 (다른 웹사이트에서 설명하기로는) viewport(현재 화면에
보여지고 있는 사각형)를 기준으로 한다고 한다.

이번에는 .box가 .right 영역을 기준으로 좌푯값이 설정되도록 position: relative를 넣어보자. 부모 태그인 .right에 넣는 것이다.

.wrap .right {
    width: 400px;
    height: 400px;
    background-color: lightblue;
    float: left;
    position: relative;
}




.box가 부모인 .right 기준으로 좌푯값이 설정되었다. 이처럼 position: relative는 자식의 좌푯값 기준을 설정할때 사용된다.

이번엔 position: fixed를 해보자. fixed는 무조건 웹브라우저를 기준으로 좌푯값이 고정된다.


&amp;lt;body&amp;gt;
&amp;lt;section&amp;gt;
    &amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;

&amp;lt;section&amp;gt;
&amp;lt;/section&amp;gt;

&amp;lt;section&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;/body&amp;gt;


section {
    width: 100%;
    height: 100vh;
}

section article {
    width: 200px;
    height: 200px;
    background-color: #000;
    position: fixed;
    bottom: 50px;
    right: 50px;
}

section:nth-of-type(1) {
    background-color: orange;
}

section:nth-of-type(2) {
    background-color: lightblue;
}

section:nth-of-type(3) {
    background-color: pink;
}


모든 section을 브라우저의 크기와 똑같이 설정한다. 1번째 article에는





스크롤을 아무리 내려도 position: fixed가 적용된 section article은 그 자리에 계속 있다.

z-index 속성 사용하기


&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;wrap&quot;&amp;gt;
    &amp;lt;div class=&quot;left&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;right&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;


.wrap {
    width: 400px;
    height: 400px;
    border: 1px solid #000;
    margin: 100px auto;
    position: relative;
}

.wrap .left {
    width: 200px;
    height: 200px;
    background-color: blue;
    position: absolute;
    top: 50px;
    left: 50px;
}

.wrap .right {
    width: 200px;
    height: 200px;
    background-color: red;
    position: absolute;
    bottom: 50px;
    right: 50px;
}




이제 left를 강제로 위로 올려보자.

.wrap .left {
    width: 200px;
    height: 200px;
    background-color: blue;
    position: absolute;
    top: 50px;
    left: 50px;
    z-index: 2;
}

.wrap .right {
    width: 200px;
    height: 200px;
    background-color: red;
    position: absolute;
    bottom: 50px;
    right: 50px;
    z-index: 1;
}



.left가 위로 올라왔다.

</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>AWS ECS task, container 메모리 제한</title>
      <url>/2023/11/16/aws-ecs-service-task-container/</url>
      <content type="text">ECS를 사용하기 위해서는 도커 먼저 이해해야한다. 도커는 client-server 어플리케이션이다. 리눅스, 윈도우, 맥OS 어느곳에나 설치되어 도커 컨테이너를 실행할 수 있게 해준다.
컨테이너란 앱 또는 앱의 일부를 실행할 가벼운 환경이다. 하나의 컴퓨터에 Docker 소프트웨어가 설치되어 있다면, 여러 가지 다른 컨테이너를 동시에 여러개 실행할 수 있다.

도커 컨테이너를 사용하면 팀원들이 모두 일관된 개발 환경을 가질 수 있다. 소프트웨어, os, 하드웨어의 구성을 어느 컴퓨터에서나 동일하고 표준적인 블록으로 추상화할 수 있기 때문이다.

Cluster



cluster는 ECS 컨테이너 인스턴스의 그룹이다. ECS는 이러한 인스턴스에 대한 일정, 유지 및 확장 요청 처리 로직을 다룬다. 또한 CPU 및 메모리 요구 사항을 기반으로 각 태스크의 최적 위치를 찾아준다.

task에 메모리 할당하기

태스크 레벨과 컨테이너 레벨 모두에서 메모리를 정의할 수 있다.

태스크 레벨에서 정의된 메모리는 그 태스크의 hard limit이라고 부른다.

컨테이너 레벨에서는 태스크에 메모리를 할당하기 위한 두 가지 파라미터가 있다. momoryReservation(soft limit)과 memory(hard limit)이다.

소프트 메모리 제한은 스케쥴러가 태스크를 인스턴스에서 실행하기 위해 메모리를 예약해두는 양이다. 소프트 제한은 짧은 시간동안 초과되기도 한다.

한편 하드 메모리 제한은 엄격히 메모리를 제한하는 limit이며 초과될 수 없다. 하드 제한이 넘어가면 컨테이너는 종료된다.


  Note! memory와 memoryReservation은 태스크 정의 &amp;gt;  컨테이너 정의에서 설정한다.


컨테이너 정의에서 momoryReservation(soft limit)나 memory(hard limit) 둘 중 하나에는 0이 아닌 Integer를 입력해야한다!
만약 둘 다 적을 것이라면 하드는 소프트보다 커야한다.
(AWS &amp;gt; aws-documentation &amp;gt; Amazon ECS &amp;gt; 개발자 안내서 &amp;gt; 파라미터 참조 및 리소스 템플릿 &amp;gt; 태스크 정의 파라미터)


참고

A beginner’s guide to Amazon’s Elastic Container Service

How can I allocate memory to tasks in Amazon ECS?

Task definition parameters
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>gunicorn, WSGI, CGI란 무엇인가, 그리고 gunicorn 사용 명령어</title>
      <url>/2023/11/15/what-is-gunicorn-wsgi-cgi/</url>
      <content type="text">pseudorec을 배포하면서 Django를 다루는 책에 gunicorn과 nginx를 다루고 있었다. 그런데 책의 마지막 챕터라 그런지 이것들에 대한 설명은 많지 않고 CS 베이스도 부족한 나는 이것들을 왜 쓰는지, 무엇인지 이해도 안갔다. 그래서 기초 수준으로 개념을 정리해본다.

웹 서버

웹 서버란 웹 브라우저(크롬 등)의 요청을 처리하는 서버이다. 웹 서버에 요청이 들어온다 치자. 예를 들어 www.pseudorec.com, www.pseudorec.com/movie/sasrec/ 등을 주소창에 치는 것이다.

웹 서버는 동적 요청이 들어오면 알맞는 파이썬 프로그램을 호출해야 할 것이다. (대표적인 웹 서버에는 아파치(Apache), 엔진엑스(Nginx) 등이 있다.) 하지만 대부분의 웹서버는 파이썬 프로그램을 호출할 수 있는 기능이 없고, 그래서 파이썬 프로그램을 호출하는 WSGI가 필요하다.
웹 서버에 동적 요청이 발생하면 웹 서버가 WSGI 서버를 호출하고, WSGI 서버는 파이썬 프로그램을 호출하여 동적 페이지 요청을 대신 처리하는 것이다. 동적 요청이란 DB의 데이터를 가져온다든지 하는, 요청을 처리한 후 응답하여 응답이 계속 변하는 요청을 말한다.

gunicorn과 WSGI

gunicorn은 wsgi(발음 위스키)의 일종이다. wsgi는 cgi에서 파생된 개념이다.

cgi는 common gateway interface의 약자로, 공통 경로 인터페이스이다. 개발하는 언어가 제각각이니, 중간의 동시통역사처럼 ‘이 문을 지나면 이러한 형태가 된다’고 정해놓은 규약이다.
사용자의 http 요청은 웹서버로 들어온다. 이 때 cgi를 통해 일관된 형태로 해석되어(번역되어) 웹서버에 전달, 웹서버 내부로 들어오는 것이다.

wsgi는 web server gateway interface의 약자로, 웹을 위해 만들어진 인터페이스다. 근데 python이란 단어가 들어가있지 않지만, python 전용으로 쓰이는 단어라고 한다. 즉, ‘웹 서버’에서의 요청을 파이썬 애플리케이션에 던지는 역할이다.
WSGI 서버는 웹서버가 동적 페이지 요청을 처리하기 위해 호출하는 서버이다.

그러니까 gunicorn은 HttpRequest를 python이 이해할 수 있게 동시통역해주는 녀석이다. Gunicorn과 uwsgi를 가장 많이 사용한다.
웹서버에 동적 페이지 요청이 발생하면 웹 서버는 WSGI 서버를 호출하고 WSGI 서버는 다시 WSGI 애플리케이션을 호출한다.
WSGI 애플리케이션에는 장고(Django), 플라스크(Flask) 등이 있다.



Gunicorn 사용 명령어
pip 명령어로 gunicorn을 설치한다. gunicorn은 서버에 설치되는 것이기 때문에 꼭 프로젝트 경로가 아니어도 된다.
pip install gunicorn


그 다음 프로젝트 경로로 이동 후 다음과 같은 명령어를 수행
gunicorn --bind 0:8000 config.wsgi:application

--bind 0:8000 : 8000번 포트를 사용하겠다는 것이다.

config.wsgi:application : config/wsgi.py 파일의 application이란 어플리케이션을 실행하겠다는 것이다.
config/wsgi.py의 application이란 예를 들면 다음과 같이 작성된다.

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault(&apos;DJANGO_SETTINGS_MODULE&apos;, &apos;config.settings&apos;)

application = get_wsgi_application()


여기서의 application이 바로 장고의 어플리케이션이며, 이 파일은 장고 프로젝트 생성시 자동으로 만들어져 있을 것이다. 따로 수정할 필요가 없다.

Worker와 Thread 수 설정

Worker

Worker는 독립적인 프로세스로, 클라이언트의 요청을 동시에 처리하는 역할을 합니다.
Gunicorn은 여러 개의 worker 프로세스를 생성하여 동시에 여러 요청을 처리할 수 있게 합니다.
각 worker는 고유한 메모리 공간을 가지고 있어, 하나의 worker가 오류로 인해 종료되더라도 다른 worker는 계속해서 서비스를 제공할 수 있습니다.
Worker의 수를 늘리면 동시에 처리할 수 있는 요청의 수가 늘어나지만, 이에 따라 메모리 사용량이 늘어나게 됩니다.

Worker 수 설정

–workers 또는 -w 옵션을 사용하여 Gunicorn이 생성할 worker 프로세스의 수를 지정할 수 있습니다. 예를 들어, -w 4는 4개의 worker를 생성하도록 지시합니다.
worker의 수는 일반적으로 코어 1개당 2-4개를 곱해 사용하면 된다.

Thread

Thread는 프로세스 내에서 동작하는 가장 작은 실행 단위입니다. thread는 자원을 공유합니다.
Python GIL(Global Interpreter Lock) 때문에 기본적으로 Python은 하나의 스레드에서만 코드를 실행할 수 있습니다. 이는 멀티코어 환경에서 병렬 처리가 어렵게 만들 수 있습니다.
그러나 I/O 바운드 작업에서는 여러 스레드를 사용하여 동시에 여러 작업을 처리할 수 있습니다.
Gunicorn에서 worker와 thread의 설정은 다음과 같습니다:

Thread 수 설정

Gunicorn은 worker 내에서 스레드를 사용할 수 있습니다. –threads 또는 -t 옵션을 사용하여 각 worker가 생성하는 스레드의 수를 지정할 수 있습니다. 예를 들어, -t 2는 각 worker가 2개의 스레드를 사용하도록 지시합니다.

이외 다른 매개변수들

-k STRING 또는 --worker-class STRING, default STRING &apos;sync&apos;

Gunicorn의 워커(worker) 클래스를 지정.


  sync :
    
      기본값으로 사용되며, 각 요청을 동기적으로 처리합니다.
      간단하고 안정적이며 대부분의 일반적인 상황에 적합합니다.
    
  
  eventlet:
    
      pip install gunicorn[eventlet] 명령을 사용하여 설치할 수 있습니다.
      Eventlet 기반의 워커로, 비동기 이벤트 기반 프로그래밍을 지원합니다.
    
  
  gevent:
    
      pip install gunicorn[gevent] 명령을 사용하여 설치할 수 있습니다.
      Gevent 라이브러리를 사용하여 이벤트 기반 및 비동기 프로그래밍을 지원합니다.
    
  
  tornado:
    
      pip install gunicorn[tornado] 명령을 사용하여 설치할 수 있습니다.
      Tornado 라이브러리를 사용하여 비동기 및 웹 소켓 지원이 특징입니다.
    
  
  gthread:
    
      pip install gunicorn[gthread] 명령을 사용하여 설치할 수 있습니다.
      Python 2에서 사용되며, futures 패키지를 통해 멀티스레딩을 지원합니다. (Python 3에서는 asyncio를 사용)
    
  


-t INT 또는 --timeout INT : Gunicorn 웹 서버의 작업자(worker)가 얼마 동안 응답을 하지 않으면 종료되고 다시 시작되어야 하는지를 설정.
기본값은 30초입니다.
이 옵션은 작업자(worker) 프로세스가 몇 초 동안 응답하지 않으면 재시작되어야 하는지를 나타냅니다.
0으로 설정하면 작업자 프로세스가 응답하지 않는 것을 무한정으로 허용하게 됩니다. 이는 모든 작업자에 대해 제한 시간을 비활성화하는 효과가 있습니다.
예를 들어, -t 30은 기본값과 동일하게 30초 동안 응답이 없으면 작업자를 재시작하도록 설정합니다.

주로, 작업자가 일정 시간 동안 응답하지 않으면 이를 감지하고 해당 작업자를 다시 시작함으로써 서버 안정성을 유지하는 데 사용됩니다. 특히 동기(sync) 작업자에 대해서는 더 높은 값으로 설정하는 것에 대해 주의가 필요하며, 일반적으로 기본값인 30초가 적절한 경우가 많습니다.

--keep-alive INT : Gunicorn 웹 서버가 Keep-Alive 연결에서 요청을 기다리는 시간을 지정. Keep-Alive는 하나의 TCP 연결을 통해 여러 HTTP 요청 및 응답을 처리할 수 있도록 하는 기술입니다.
기본값은 2초입니다.
이 옵션은 Keep-Alive 연결에서 요청을 기다리는 시간을 나타냅니다.
보통은 1-5초의 범위 내에서 설정되며, 특히 클라이언트와 직접 연결된 서버의 경우 사용됩니다. (예: 로드 밸런서가 없는 경우)
로드 밸런서 뒤에 Gunicorn이 배치된 경우, 이 값을 더 높게 설정하는 것이 합리적일 수 있습니다.
이 옵션을 조정함으로써, 서버가 Keep-Alive 연결을 유지하는 동안 클라이언트로부터의 추가 요청에 대한 응답을 더 빠르게 처리하거나, 로드 밸런서와 같은 중간 계층이 요청을 전달하는 데 걸리는 시간에 대한 대응을 조절할 수 있습니다.

만약 로드 밸런서가 있는 환경에서 작업 중이라면, 로드 밸런서와의 통신 및 Keep-Alive 설정에 대한 문서도 함께 확인하는 것이 좋습니다.

출처
점프 투 장고 - 4-09 WSGI

gunicorn은 대체 뭐하는 놈일까 (부제: CGI, WSGI는 대체 뭐냐)
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Docker 내 gunicorn 사용시 memory usage 확인</title>
      <url>/2023/11/15/docker-gunicorn-memory-usage-check/</url>
      <content type="text">도커 컨테이너에서 Gunicorn을 실행 중일 때, 메모리 사용량을 확인하는 방법


  도커 CLI를 통한 메모리 통계 확인:
    
      다음 명령을 사용하여 도커 컨테이너의 메모리 사용량을 확인할 수 있습니다.
        docker stats [options] [container_name]
        
        
          container_name은 Gunicorn이 실행 중인 컨테이너의 이름 또는 ID로 대체됩니다.
          이 명령은 실시간으로 CPU, 메모리, 네트워크 등의 통계를 표시합니다.
        
      
    
  



  
    
      Column name
      Description
    
  
  
    
      CONTAINER ID and Name
      the ID and name of the container
    
    
      CPU % and MEM %
      the percentage of the host’s CPU and memory the container is using
    
    
      MEM USAGE / LIMIT
      the total memory the container is using, and the total amount of memory it is allowed to use
    
    
      NET I/O
      The amount of data the container has received and sent over its network interface
    
    
      BLOCK I/O
      The amount of data the container has written to and read from block devices on the host
    
    
      PIDs
      The number of processes or threads the container has created
    
  



  도커 컨테이너 내부에서 Gunicorn 프로세스의 메모리 사용량 확인:
    
      컨테이너 내부에서 직접 Gunicorn 프로세스의 메모리 사용량을 확인할 수 있습니다.
      ps나 top 명령을 사용할 수 있습니다. 예를 들어:
        docker exec -it [container_name] ps aux
        
        또는
        docker exec -it [container_name] top
        
        
          container_name은 Gunicorn이 실행 중인 컨테이너의 이름 또는 ID로 대체됩니다.
          이 명령은 컨테이너 내부에서 실행 중인 모든 프로세스의 목록과 자원 사용량을 표시합니다.
        
      
    
  
  도커 컨테이너의 로그 확인:
    
      Gunicorn은 로그에 메모리 사용에 관한 정보를 기록할 수 있습니다. Gunicorn 로그를 확인하여 메모리 사용량을 파악할 수 있습니다.
      Gunicorn 로그는 일반적으로 STDOUT 또는 특정 로그 파일에 출력됩니다.
    
  
  도커 컨테이너의 메모리 리소스 사용 확인:
    
      도커는 docker stats 명령 외에도 docker inspect를 사용하여 컨테이너의 자세한 정보를 얻을 수 있습니다.
              
docker inspect --format=&apos;{{.Config.Memory}}&apos; [container_name]
      
        
        
          container_name은 Gunicorn이 실행 중인 컨테이너의 이름 또는 ID로 대체됩니다.
          이 명령은 컨테이너가 할당된 메모리 양을 표시합니다.
        
      
    
  
  컨테이너의 메모리 한도 확인
    
      컨테이너 메모리 구성을 확인하는 명령어
              
 docker inspect --format=&apos;{{.Config.Memory}}&apos; &amp;lt;container_id_or_name&amp;gt;
 # 이게 안되면 Docker inspect 결과에서 &quot;Memory&quot; 필드가 존재하지 않는다는 의미이므로 아래와같이
 docker inspect --format=&apos;{{.HostConfig.Memory}}&apos; &amp;lt;container_id_or_name&amp;gt;
      
        

        모든 설정을 보고 싶다면 다음과 같이!
         docker inspect 962ec674f2c5
        
      
    
  


이러한 방법 중 하나를 선택하여 Gunicorn이 실행 중인 도커 컨테이너의 메모리 사용량을 확인할 수 있다.
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Python cx_Oracle 모듈 사용하여 Oracle DB 연결 - cursor, connection, pool이란</title>
      <url>/2023/10/27/cx-oracle/</url>
      <content type="text">python에서 oracle db에 연결할 때 cs_Oracle이란 라이브러리를 사용하게 된다. 이 때 cursor, connection을 매번 호출하는 것보다 pool을 만들어놓고 재사용하면 효율이 좋아진다고 해서 알아보게 되었다.
cx_Oracle 공식문서인 Connecting to Oracle Database를 번역했습니다.

시작 전 connection과 cursor 기본개념
Connection 객체로부터 cursor() 메서드를 호출하여 Cursor객체를 가져오게 된다. Cursor는 Fetch 동작, 즉 데이터를 데이터 조회 동작을 관리한다. Cursor의 execute() 메서드를 사용하여 SQL 문장을 DB 서버에 보낸다.(출처 : 예제로 배우는 파이썬 프로그래밍-MySQL쿼리)

sql문장의 리턴값은 cursor 객체에 들어있고 cursor.fetchone(), cursor.fetchmany(size), cursor.fetchall()이라는 친구들로 원하는 만큼만 꺼내올 수 있다.
cursor객체에서 데이터를 가져오고 싶으면 fetch 메소드를 사용해서 가져와야 한다.(출처 : Min-Ho’s log

cursor.fetchall() 쿼리 결과의 모든 row을 튜플의 리스트 형태로 리턴한다. fetch할 것이 없으면 빈 리스트를 리턴한다.

cursor.fetchmany(size) size만큼의 row를 리턴한다. 반복해서 호출할 때마다 다음 셋을 튜플의 리스트 형태로 리턴한다. 더이상 row가 없다면 빈 리스트를 리턴한다.

cursor.fetchone()  하나만 리턴한다. row가 더이상 없다면 None을 리턴한다.

출처

Database Connection 생성/설정
cx_Oracle을 이용해 Oracle 데이터베이스에 연결하는 방법은 두 가지가 있다.

1. Standalone connections

어플리케이션이 데이터베이스에 싱글 유저 세션을 유지할 때 유용함. cx_Oracle.connect() 또는 alias인 cx_Oracle.Connection()으로 생성.

Example) Standalone Connection to Oracle Database

import cx_Oracle
userpwd = &quot;. . .&quot;  # 패스워드는 프롬프트로부터 받거나 환경변수로 받으면 된다
connection = cx_Oracle.connect(user=&quot;hr&quot;, 
                               password=userpwd,
                               dsn=&quot;dbhost.example.com/orclpdb1&quot;,  # data source name
                               encoding=&quot;UTF-8&quot;)


Closing Connections

연결이 더 이상 필요하지 않을 때 Connection.close()를 호출하여 연결을 해제해야 한다. 또는 연결에 대한 참조가 범위를 벗어나면(references go out of scope라고 표현) 자동으로 정리되도록 해도 된다. 또는 with 블록을 사용해도 된다.
with cx_Oracle.connect(user=user, 
                       password=password,
                       dsn=&quot;dbhost.example.com/orclpdb1&quot;,
                       encoding=&quot;UTF-8&quot;) as connection:
    cursor = connection.cursor()
    cursor.execute(&quot;insert into SomeTable values (:1, :2)&quot;,
                   (1, &quot;Some string&quot;))
    connection.commit()

이런식으로 블록으로 짜면 블록이 끝날때 connection은 닫히게 된다. 물론 블록 밖에서 connection 변수는 사용할 수 없다. 커넥션을 즉시 닫는 것은 커넥션 풀을 사용할 때 매우 중요하다. 다른 pool 유저가 재사용 할 수 있도록.

Connection Strings

cx_Oracle.connect() 과 cx_Oracle.SessionPool()에는 data source name을 나타내는 파라미터 dsn이 있다. 
이는 Oracle Database connection string(string은 방법, 코드라고 보면 될 것 같다)이라고 해서 연결할 데이터베이스를 식별하는 역할을 한다. dsn string은 다음 중 하나로 만들 수 있다.

  An Oracle Easy Connect string
  An Oracle Net Connect Descriptor string
  A Net Service Name mapping to a connect descriptor


하나씩 알아보자.

Easy Connect Syntax for Connection Strings

가장 간단한 connection string이다. tnsnames.ora같은 configuration 파일이 필요없다.

Example) 예를들어 서비스가 orclpdb1이고 host가 dbhost.example.com이면 다음과 같이 사용한다.
connection = cx_Oracle.connect(user=&quot;hr&quot;, password=userpwd,
                               dsn=&quot;dbhost.example.com/orclpdb1&quot;,
                               encoding=&quot;UTF-8&quot;)

디폴트 port가 없는 데이터 베이스라면 dsn은 &quot;dbhost.example.com:1984/orclpdb1&quot;처럼 써야한다.

Easy Connect Syntax는 예전 sid를 사용할 수 없고 service name을 지원한다.

Oracle Net Connect Descriptor Strings

cx_Oracle.makedsn() 함수는 cx_Oracle.connect() 과 cx_Oracle.SessionPool()의 dsn 파라미터, 즉 connect descriptor string을 만드는데 사용된다.
makedsn()함수는 데이터베이스의 hostname, port 번호, service name을 인자로 받는다.

Example) 예를들어 서비스가 orclpdb1이고 host가 dbhost.example.com이면 다음과 같이 사용한다.
dsn = cx_Oracle.makedsn(&quot;dbhost.example.com&quot;, 1521, service_name=&quot;orclpdb1&quot;)
connection = cx_Oracle.connect(user=&quot;hr&quot;, password=userpwd, dsn=dsn,
                               encoding=&quot;UTF-8&quot;)

service_name을 명시하는 이유는 세 번째 파라미터가 service name이 아닌 sid(system identifier)이기 때문이다. 그러나 대부분의 데이터베이스들은 service name을 주로 사용한다.
dsn으로 넘어가는 인자는 다음과 같아진다.
(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=dbhost.example.com)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=orclpdb1)))


Net Service Names for Connection Strings



2. Pooled connections

커넥션 풀링(Connection pooling)은 어플리케이션이 데이터베이스에 자주 연결/연결해제를 할때 성능에 있어 중요한 요소이다. 풀(Pools)은 오라클의 *고가용성(high availability) 특징을 지원하고 신뢰해야하는 어플리케이션에 추천한다.
작은 풀(small pools) 또한 단지 몇 번의 연결만 원할 때 유용할 수 있다. Pool은 어플리케이션 초기화할 때 cx_Oracle.SessionPool()로 생성하면 되고, SessionPool.acquire()을 이용해 pool로부터 connection을 가져올 수 있다.

*고가용성(High Availability) : 시스템이 연속적으로 가동되며 사용 가능한 상태를 유지하는 능력. 시스템 또는 데이터베이스가 장애, 오류, 혹은 다른 문제로부터 회복하고 사용자에게 끊김 없이 서비스를 제공할 수 있는 더 높은 신뢰성

Connection Pooling

cx_Oracle의 connection pooling은 어플리케이션들이 데이터베이스로의 connection의 pool을 생성/관리할 수 있게 한다.
하나의 connection pool은 SessionPool()로 생성할 수 있다. 일반적으로 어플리케이션 초기화중에 호출된다. Pool 생성시에 initial pool size와 maximum pool size를 넘겨준다.

pool이 더 많은 연결을 필요로 할 때, 새로운 연결이 자동으로 생성된다. 연결이 더이상 필요하지 않을 때 pool은 min으로 취소될 수 있다.

Pool이 만들어진 후, acquire()를 호출하면 connection을 얻을 수 있다. 이 connection들을 standalone connection 사용 방식과 동일하게 사용하면 된다.
Pool에서 얻어진 connection은 사용하고 나면  SessionPool.release() 또는 Connection.close()를 사용하여 다시 pool로 회수할 수 있다. 그렇지 않으면 connection을 참조하는 모든 변수들이 scope를 벗어날 때 회수된다.
session pool은 SessionPool.close()를 사용하면 완전히 닫을 수 있다.

SessionPool에서 session이란 ‘데이터베이스와의 연결’을 나타낸다고 보면 될 것 같다(chatgpt).


  min : 세션 풀이 생성될 때 사용된 세션의 수와 세션 풀에서 관리될 최소 세션 수
  max : 세션 풀이 제어할 수 있는 세션의 최대 수
  increment : 추가 세션이 생성되어야 할 때, 생성될 세션의 수.


Example
# session pool 생성
pool = cx_Oracle.SessionPool(user=&quot;hr&quot;, 
                             password=userpwd,
                             dsn=&quot;dbhost.example.com/orclpdb1&quot;, 
                             min=2, max=5, increment=1, 
                             encoding=&quot;UTF-8&quot;)

# Acquire a connection from the pool
connection = pool.acquire()

# Use the pooled connection
cursor = connection.cursor()
for result in cursor.execute(&quot;select * from mytab&quot;):
    print(result)

# Release the connection to the pool
pool.release(connection)

# Close the pool
pool.close()


SessionPool 생성할 때 getmode 옵션을 주면 acquire() 호출 시 모든 connection이 사용중이더라도 사용 가능한 상태가 될때까지 기다린다.

# Create the session pool
pool = cx_Oracle.SessionPool(user=&quot;hr&quot;, 
                             password=userpwd,
                             dsn=&quot;dbhost.example.com/orclpdb1&quot;,
                             min=2, max=5, increment=1,
                             getmode=cx_Oracle.SPOOL_ATTRVAL_WAIT,
                             encoding=&quot;UTF-8&quot;)


SessionPool.acquire()는 리턴하기 전에 cx_Oracle은 네트워크 전송이 open된 상태인지 가벼운 체크를 한다. 만약 open 상태가 아니라면 acquire()는 해당 connection을 폐기하고 다른 connection을 리턴한다.
그치만 데이터베이스 세션이 DBA에 의해 죽었는지, 데이터베이스 리소스 매니저 quota limit에 도달했는지는 알지 못한다.
이를 해결하기 위해 acquire()는 pool 안의 사용되지 않았던 connection을 반환할 때 full round-trip ping(왕복)을 데이터베이스에 SessionPool.ping_interval 초 만큼 수행한다.
만약 ping이 실패하면 해당 connection은 버려지고 다른 connection이 얻어진다.
full ping은 시간 기반이므로, 모든 실패를 잡아내지 못한다. 또한 타임아웃이나 세션 킬은 acquire()다음과  cursor.execute() 전 시간 안에 일어날 수도 있다.
이를 해결하기 위해 어플리케이션은 각각의 acquire() 이후에 에러를 체크하고 어플리케이션만의 retry를 할 필요가 있다.

Connection Pool Sizing

오라클이 추천하는 방식은 고정된 size의 connection pool을 사용하는 것이다. 즉 min과 max를 같게 하고 ìncrement를 0으로 하는 것이다.
이것이 Connection storm, 즉 여러 client가 동시에 DB 연결을 시도하여 과도한 수의 connection이 설정되는 장애 상황을 예방할 수 있다.



배치문 실행 및 Bulk 로딩

cursor.execute()는 sql 한 줄만 수행하지만, 값만 바꿔 여러번 실행할 때는 cursor.executemany()를 사용하면 된다.
data = [
    (10, &apos;Parent 10&apos;),
    (20, &apos;Parent 20&apos;),
    (30, &apos;Parent 30&apos;),
    (40, &apos;Parent 40&apos;),
    (50, &apos;Parent 50&apos;)
]
cursor.executemany(&quot;insert into ParentTable values (:1, :2)&quot;, data)


출처

pool로부터 확인할 수 있는 정보는 다음과 같다.

pool.busy :  현재 acquire()된 세션 수를 반환한다.

pool.opened : 현재 session pool에 의해 열린 세션 수를 반환한다.

opened와 busy의 차이 : opened는 pool에 의해 현재 열린, pool안에 있는 세션의 수를 나타낸다. pool이 현재 확보하고 있는 세션의 수.
busy는 pool 속의 세션 중에서 현재 작업 중인 세션(=connection 인 것 같다), 즉 쿼리나 다른 작업을 처리 중인 세션의 수를 나타낸다.

pool = cx_Oracle.SessionPool(user=properties[&apos;user&apos;], 
                             password=properties[&apos;passwd&apos;],
                             dsn=dsn, 
                             min=1, max=5, increment=1, 
                             encoding=&quot;UTF-8&quot;)
print(pool.opened)  # 1
print(pool.busy)  # 0

connection = pool.acquire()
print(pool.opened)  # 1
print(pool.busy)  # 1

connection2 = pool.acquire()
print(pool.opened)  # 2
print(pool.busy)  # 2

pool.release(connection2)  # pool로 반환
print(pool.opened)  # 2
print(pool.busy)  # 1



만약 increment가 2였다면, 두 번째 세션을 얻는 connection2 = pool.acquire()를 할 때 pool.opened는 3이 된다. 2개를 여니까.
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>논문리뷰 - Collaborative filtering for Implicit Feedback Datasets</title>
      <url>/2023/10/15/cf-for-implicit/</url>
      <content type="text">오랜만에 논문 리뷰!! 가짜연구소 ‘추천시스템 논문에서 서비스까지’ 스터디 진행 중 이 논문을 리뷰하고 구현하면 좋을 것 같아 이번에 annotation 방식으로 리뷰해본다.












</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>논문리뷰 - Contrastive Learning for Sequential Recommendation</title>
      <url>/2023/09/19/Contrastive-Learning-for-Sequential-Recommendation/</url>
      <content type="text">CL4SREC은 전통적인 ‘next item prediction’ 태스크의 장점을 이용할 뿐만 아니라 contrastive learning의 프레임워크를 사용하여 아이템 시퀀스로부터 self-supervision signal을 추출한다.
그렇기에 더욱 의미 있는 유저 패턴을 추출할 수 있고 유저 표현을 더욱 효과적으로 인코딩할 수 있다.

논문 : Contrastive Learning for Sequential Recommendation



Self-supervised Learning(SSL, 자기지도학습)
self-supervised learning은 라벨없는 데이터에서 representation을 학습하는데에 우월하다고 한다. 기본 아이디어는 pretext task로 training signal을 구축하는 것이다.

CL4SREC

Notations &amp;amp; 문제 정의

유저를 \(u\), 아이템을 \(v\)라고 하자.
유저 \(u\)의 인터랙션 시퀀스 \(s_u\)는 \(s_u=\left[v_1^{(u)}, v_2^{(u)}, \cdots, v_{|s_u|}^{(u)}\right]\)처럼 쓸 수 있다.
여기서 \(|s_u|\)는 시퀀스 길이가 된다.

시퀀셜 추천을 정의하자. 유저 \(u\)가 \(|s_u|+1\) 시간에 가장 상호작용할 가능성이 높은 아이템을 예측한다.
다른 보조적인 문맥 정보는 사용하지 않고, 오직 유저의 상호작용 시퀀스만 주어진다. 다음과 같이 수식화된다.

\[v_u^* = \arg\max_{v_i \in \mathcal{V}} P\left( v_{|s_u|+1}^{(u)} = v_i | s_u \right)\]

Contrastive Learning Framework

프레임워크는 크게 세 가지로 구성된다.



1. 증강 모듈(Data Augmentation Module)

\(\mathcal{A}\)를 augmentation method들의 집합이라고 하자. 즉 \(\mathcal{A}\)에는 뒤에 나올 crop, mask, reorder가 들어있다. 
증강 모듈은 하나의 데이터에 대해 2개의 augmentation을 만든다. 만약 두 augmentation이 같은 샘플로부터 나온 것이라면 이 둘은 positive pair라고 정의한다.
각각 다른 샘플로부터 변형된 것이라면 negative pair라고 정의한다.
Augmentation 방법은 \(\mathcal{A}\)로부터 무작위로 2개를 뽑아 \(a_i\)와 \(a_j\)라고 부르기로 하고(예를 들면 \(a_i\) : Crop, \(a_j\) : Mask), 이를 \(s_u\)라는 시퀀스에 적용한다.
결과는 각각 \(s_u^{a_i}\)와 \(s_u^{a_j}\)라고 나타낸다.

2. 유저 인코더(User Representation Encoder)

인코더로 트랜스포머를 사용한다. 증강된 시퀀스로부터 유저 representation을 추출한다.

3. 대조 손실 함수(Contrastive Loss Function)

손실함수는 두 representation이 같은 유저 시퀀스로부터 추출된 것인지 구별한다. 손실함수는 다음을 각각 최소화, 최대화한다.

  최소화 : 하나의 유저시퀀스로부터 변형된 두 시퀀스간 차이
  최대화 : 각각 다른 유저 시퀀스로부터 변형된 두 시퀀스간 차이


\[\mathcal{L}_{\text{cl}}(s_u^{a_i}, s_u^{a_j})=-\log \frac{\exp(\text{sim}(s_u^{a_i}, s_u^{a_j}))}{\exp(\text{sim}(s_u^{a_i}, s_u^{a_j}))+\sum_{s^- \in S^-}\exp(\text{sim}(s_u^{a_i}, s_u^-))}\]

\(\text{sim}(u, v)=u^Tv\), 즉 내적이다. 손실을 작게 한다 = -를 뗀 log를 크게 한다 = \(s_u^{a_i}\)와 \(s_u^{a_j}\)를 유사하게 한다 + \(s_u^{a_i}\)와 \(S^-\)에 속한 것들과는 멀어지게 한다가 되겠다.

Data Augmentation Operators



1. Crop

시퀀스 내부의 연속된 일부만 떼어낸다. 예를 들어 \([v_1, v_2, v_3, v_4, v_5, v_6, v_7]\)이라는 7개의 아이템으로 구성된 시퀀스가 있고, 전체 길이 7의 0.6만큼만 crop한다고 하고(내림하여 4개), 2번 아이템부터 crop한다고 했을때 augmentation 결과는 \([v_2, v_3, v_4, v_5]\)가 된다.

2. Mask

일부 아이템을 \([mask]\)라는 스페셜 아이템으로 변환한다. 만약 시퀀스 길이의 0.3만큼만 마스킹하고싶다면 7 X 0.3 = 2.1을 내림한 2개를 랜덤으로 마스킹한다.

3. Reorder

시퀀스 내부의 연속된 시퀀스를 무작위 재배치한다. 예를들어 3번 아이템부터 0.6만큼의 아이템, 즉 4개를 재배치한다면 \([v_1, v_2, v_5, v_3, v_6, v_4, v_7]\)처럼 된다.

User Representation Model
인코더 모델로는 SASRec을 사용한다(SASRec 논문리뷰 참고). 유저 representation으로는 마지막 아이템까지 어텐션을 적용한 representation, 즉 \(t=|s_u|\)(마지막)째 아이템의 representation을 사용한다.

Multi-task Training
multi-task 전략을 사용한다고 하는데, 특별한게 아니다. \(\mathcal{L}_{\text{cl}}\)뿐만 아니라 SASRec 자체의 next item prediction 손실까지 더하겠다는 뜻이다.
이를 \(\mathcal{L}_{\text{main}}\)이라고 할 때, total loss는 다음과 같다.
\(\mathcal{L}_{\text{total}} = \mathcal{L}_{\text{main}} + \lambda \mathcal{L}_{\text{cl}}\)

\(\mathcal{L}_{\text{main}}\)은 다음과 같이 정의된다.

\[\mathcal{L}_{\text{main}}(s_{u, t}) = \frac{\exp(s_{u,t}^T v_{t+1}^+)}{\exp(s_{u, t}^T v_{t+1}^+) + \sum_{v_{t+1}^- \in \mathcal{V}^-} \exp(s_{u,t}^T v_{t+1}^-)}\]

\(s_{u, t}\)는 계산된 유저 representation을 의미하고, \(v_{t+1}^+\)는 \(t+1\)에서의 아이템, \(v_{t+1}^-\)는 무작위 샘플링된 네거티브 아이템을 의미한다.

Experiments

사용한 데이터셋은 다음과 같다.


Crop, mask, reorder에서 사용하는 비율은 다음과 같다.

  crop : \(\eta\)(eta)
  mask : \(\gamma\)(gamma)
  reorder : \(\beta\)(beta)

</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Django MVT 패턴 기초</title>
      <url>/2023/08/30/Django/</url>
      <content type="text">
  유저가 가게에 접속한다. -&amp;gt; 유저가 url로 접속한다.
  유저는 주문 받는 직원(URLconf)에게 request를 보낸다. -&amp;gt; URL 설정(URLconf)는 요청자가 브라우저의 주소 표시줄로 전달한 URL로부터 어떤 페이지를 요청했는지 구분해준다.
  주문을 처리하는 직원(View)은 음식을 만들어 응답을 되돌려준다.
  만들어진 음식을 유저가 가져간다 -&amp;gt; 브라우저가 응답(Response)를 화면에 표시한다.


Model
Model은 메뉴를 만들기 위한 재료들을 저장하는 창고다. 엑셀의 시트, 데이터베이스의 테이블이다.

Model은 파이썬의 class 형태이며, 장고와 DB를 연결시키는 코드이자 데이터의 형태다. 일반적으로, 1개의 모델은 DB의 1개의 테이블과 매핑된다.

django.db.models.Model 클래스를 상속받는다. 예를 들면 다음과 같다:
class DjangoModel(models.Model):
    name = models.CharField(&quot;이름&quot;)


Template
템플릿(Template)은 HTML 파일이다. 보통 templates/ 디렉토리 내에 HTML 파일을 사용한다.

View
주문 받는 직원이다.

View는 파이썬의 함수 형태이며, request를 받아 처리한다. 파일명은 기본값으로 views.py를 사용한다.

from django.http import HttpResponse

def main(request):
    return HttpResponse(&quot;안녕하세요, pyburger 햄버거집입니다.&quot;)



url과 view를 연결
주문을 받는 직원 URLconf는 config/urls.py에 다음과 같이 구현한다.
from django.contrib import admin
from django.urls import path
from config.views import main  # views.py에 작성한 main함수를 가져온다

urlpatterns = [
    path(&apos;admin/&apos;, admin.site.urls),
    path(&quot;&quot;, main),  # &quot;&quot;(공백)인 경로와 views/main 함수를 연결
]


이렇게 하면 localhost:8000 기본주소로 들어가면 “안녕하세요, pyburger 햄버거집입니다.” 문자열을 볼 수 있다!
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>논문리뷰 - SASRrec</title>
      <url>/2023/03/26/SASRec-review/</url>
      <content type="text">논문 : https://arxiv.org/abs/1808.09781











</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Implicit data 추천시스템에서의 nDCG</title>
      <url>/2023/01/15/Implicit-data-recommendation-nDCG/</url>
      <content type="text">nDCG의 기본 수식은 다음과 같습니다 :

\[NDCG@K = Z_K \sum_{i=1}^{K} \frac{2^{rel_i}-1}{\log_2(i+1)}\]

\(Z_K\)는 제일 좋은 성능일 때를 1로 만들기 위한 normalizer입니다. 보통은 1로 놓습니다. \(rel_i\)는 $i$번째 아이템의 graded relavance입니다. implicit data이기 때문에 \(rel_i\)는 1 또는 0이며, 1일 때는 아이템이 test set에 존재할 때이고, 0일 때는 그렇지 않을 때입니다.

예시
예를 들어 K=5라고 해보겠습니다.


다음과 같이 t라는 유저가 있고, 이 유저는 1~5까지 5개의 아이템을 사용(클릭)했고 6~10 아이템은 사용하지 않았다고 해봅시다.



사용한 아이템을 train과 test로 나누게 될 것입니다. 그리고 train으로 학습이 진행될 것입니다. 이제 테스트 시간이 왔다고 해봅시다.



모델이 다음 클릭으로 예측한 결과가 6, 4, 8, 5, 10 순으로 높은 스코어가 나왔다고 해봅시다. 테스트 유저가 실제로 클릭한 test셋인 아이템은 4, 5입니다. 모델이 4, 5를 높은 순위로 예측했다면 좋은 모델이라고 할 수 있습니다. 이 true label set, 즉 test set인 4, 5 아이템 간의 시간 순서 등은 사용되지 않습니다.

idcg를 구해봅시다. idcg는 모델 예측이 true label set으로 1위부터 쭉 나열된 경우, 말그대로 ideal한 상황에서 nDCG를 계산한 값입니다. 위 수식에 따르면 :

\[\begin{align*}\text{idcg(ideal dcg)} &amp;amp;= \sum_{i=1}^{k} \frac{2^{r_i}-1}{\log_2(i+1)}\\
&amp;amp;=\frac{1}{\log_2{(1+1)}}+\frac{1}{\log_2{(2+1)}}+\frac{0}{\log_2{(3+1)}}+\frac{0}{\log_2{(4+1)}}+\frac{0}{\log_2{(5+1)}}\\
&amp;amp;=1.6309
\end{align*}\]

4, 5 아이템이 1, 2등인 상황에서 구한 값입니다.

이제 dcg를 구해봅시다. dcg는 \(k=5\)까지 계산한 값입니다:

\[\begin{align*}\text{dcg} &amp;amp;= \sum_{i=1}^{k} \frac{2^{r_i}-1}{\log_2(i+1)}\\
&amp;amp;=\frac{0}{\log_2{(1+1)}}+\frac{1}{\log_2{(2+1)}}+\frac{0}{\log_2{(3+1)}}+\frac{1}{\log_2{(4+1)}}+\frac{0}{\log_2{(5+1)}}\\
&amp;amp;=1.0616
\end{align*}\]

\(ndcg=\frac{dcg}{idcg}\)로 계산합니다.
\(\text{nDCG@5}=\frac{dcg}{idcg}=\frac{1.0616}{1.6309}=0.6509\)



논문 TriRank: Review-aware Explainable Recommendation by Modeling Aspects의 일부를 참고했습니다.
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Node2Vec</title>
      <url>/2023/01/13/Node2Vec/</url>
      <content type="text">Node2vec은 말그대로 노드를 벡터표현으로 나타내는 방법 중 하나입니다. 모델의 목적은 그래프 속에서 유사한(이웃한) 노드들이 임베딩 공간에서도 근처에 있도록 매핑하는 것입니다. 즉, 한 노드 입장에서 이웃 노드가 등장할 확률을 최대화하는 것입니다.
논문 : node2vec: Scalable Feature Learning for Networks



</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>추천시스템에서의 Matrix Factorization</title>
      <url>/2022/12/27/Matrix-Factorization-in-RS/</url>
      <content type="text">논문 Neural collaborative filtering에서 짧게 추천에 관한 Matrix Factorization에 대해 설명하길래 따로 정리해봤다.

MF는 유저와 아이템을 latent feature의 실수 벡터와 연결한다. \(\mathbf{p}_u\)와 \(\mathbf{q}_i\)가 유저 와 아이템 를 나타낸다고 해보자. MF는 \(\mathbf{p}_u\)와 \(\mathbf{q}_i\)를 내적하여 상호작용 \(y_{ui}\)를 계산한다.

\[\hat{y}_{ui}=f(u,i|\mathbf{p}_u, \mathbf{q}_i)=\mathbf{p}_u^T\mathbf{q}_i=\sum_{k=1}^{K}p_{uk}q_{ik}\]

K는 latent space의 차원을 나타낸다. MF는 잠재 공간의 각 차원이 서로 독립적이고 동일한 가중치로 선형 결합한다고 가정하여 유저 및 아이템 잠재 요인(latent factor)의 양방향 상호 작용을 모델링한다. 그렇기 때문에 MF는 잠재 요인의 선형 모델로 여겨진다.

Figure 1

Figure 1은 내적이 어떻게 MF의 표현력을 제안할 수 있는지를 보여준다. 이 예시를 이해하기 위해 우선적으로 두 가지만 얘기하고 넘어가자. 첫 번째, MF는 유저와 아이템을 같은 잠재 공간(latent space)로 매핑하기 때문에 두 유저간의 유사도 또한 내적(같은 방법으로 잠재벡터 사이의 코사인 각도)으로 계산될 수 있다. 두 번째로, 일반화 손실 없이, 우리는 MF가 복구해야 하는 두 유저의 실제 유사도로서 자카드 계수를 사용한다.

Figure 1a의 상위 3개의 row를 보자. \(s_{23}(0.66) &amp;gt; s_{12}(0.5) &amp;gt; s_{13}(0.4)\)를 계산하기는 쉽다. 
그렇게 해서, 잠재 공간에서의 \(\mathbf{p}_1\)과 \(\mathbf{p}_2\) , 그리고 \(\mathbf{p}_3\)의 기하학적 관계는 Figure 1b처럼 그릴 수 있다. 
자 이제 새로운 유저 \(u_4\)를 고려해보자. 
\(s_{41}(0.6) &amp;gt; s_{43}(0.4) &amp;gt; s_{42}(0.2)\)로 계산되는데, 이는 \(u_4$가\)u_1\(과 가장 유사하고, 그 다음으로\)u_3\(와, 그 다음으로\)u_2\(순으로 유사하다는 뜻이다. 
그러나, 만약 MF 모델이\)\mathbf{p}_4\(를\)\mathbf{p}_1\(에 가장 가깝게 놓는다면\)\mathbf{p}_4\(가\)\mathbf{p}_3\(보다\)\mathbf{p}_2$$에 더 가까워지게 되어 큰 랭킹 손실이 생길 것이다.

위 예시는 MF가 복잡한 유저-아이템 상호작용을 저차원의 잠재 공간에서 간단하고 고정적인 내적으로 계산하려 할 때 발생할 수 있는 한계를 보여준다. 한 가지 해결 방법은 K를 늘리는 것이다. 그러나 이는 sparse한 상황에서는 역으로 모델의 일반화 성능을 저하시킬 수 있다(e.g., 오버피팅). 본 논문에서는 Deep Neural Network를 이용하여 상호작용 함수를 학습시킴으로써 이러한 한계를 다룬다.



</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>논문리뷰 - NGCF</title>
      <url>/2022/11/10/ngcf-review/</url>
      <content type="text">Neural graph collaborative filtering(2019) 논문의 Methodology 부분을 다룹니다. 논문에서 Methodology에 대한 설명은 크게 세 부분으로 구성되어 있습니다.

pytorch 코드 : huangtinglin/NGCF-PyTorch


  Embedding Layer
  Embedding Propagation Layers
    
      First-order propagation
      High-order propagation
    
  
  Model Prediction
  Optimization


1. Embedding Layer

메인스트림 추천모델인 Unifying Knowledge Graph Learning and Recommendation, NCF, BPR에 따르면, 유저 \(u\)(아이템 \(i\))는 임베딩 벡터 \(\mathbf{e}_u \in \mathbb{R}^d(\mathbf{e}_i \in \mathbb{R}^d)\)로 나타낸다. 즉 \(d\)차원의 임베딩 벡터로.



MF나 NCF같은 기존 모델은 임베딩을 바로 interaction layer로 전달하여, 즉 바로 내적하거나 신경망에 전달해서 예측 스코어를 계산합니다.
하지만 NGCF는 유저-아이템 그래프 상에서 propagating하여 임베딩을 정교화(refine이라고 표현)합니다.
이걸 임베딩 정교화(embedding refinement) step이라고 하는데, 이 과정을 통해 collaborative signal을 임베딩에 주입할 수 있기 때문이라고 합니다.

2. Embedding Propagation Layers

GNN의 message-passing 아키텍쳐를 이용하여 그래프 구조를 따라 CF 시그널을 잡아내고 유저-아이템 임베딩을 정교화합니다.
우선 하나의 레이어에서 어떻게 전파가 이루어지는지 확인하고, 여러 레이어로 확장해봅시다.

1. First-order propagation

직관적으로 봤을 때, 어느 유저에 의해 사용된(클릭된) 아이템은 해당 유저의 선호도를 구성할 수 있습니다.
마찬가지로, 특정 아이템을 사용한 유저들은 해당 아이템의 특징을 구성하고 있습니다.
또한 두 아이템의 유사도를 측정하는데 사용될 수도 있을 겁니다.
이러한 가정을 기반으로, 상호작용한 유저와 아이템 사이에 임베딩 전파를 수행합니다.
이 때, message construction과 message aggregation이라는 개념이 사용됩니다.

Message Construction

서로 연결된 유저-아이템 쌍 \((u, i)\)에 대하여, \(i\)에서 \(u\)로의 message를 다음과 같이 정의합니다.

\[m_{u \leftarrow i} = f(e_i, e_u, p_{ui})\]

\(m_{u \leftarrow i}\)는 메시지 임베딩, 즉 전파되는 정보를 의미합니다. \(f(\cdot)\)는 메시지 인코딩 함수라고 하며, 임베딩 \(e_i\)
와 \(e_u\), 그리고 \(\text{edge}(u, i)\)의 전파에 대한 감쇠인자(decay factor)를 조정하기 위한 계수 p_{ui}를 인풋으로 받습니다.

본 논문에서는 \(f(\cdot)\)을 다음과 같이 정의합니다:

\[m_{u \leftarrow i} = \frac{1}{\sqrt{|N_{u}||N_i|}}(W_1 \textbf{e}_i + W_2(e_i \odot e_u))\]

\(W_1, W_2 \in \mathbb{R}^{d&apos; \times d}\)는 학습 가능한 가중치 행렬입니다.
이 행렬은 전파라는 것이 유용한 정보를 추출(또는 정제, distill)합니다.
전통적인 Graph convolutional networks(
2016.Convolutional Neural Networks on Graphs with Fast Localized Spectral Filtering., 
2017. Semi-Supervised Classification with Graph Convolutional Networks.,
2017. Graph Convolutional Matrix Completion.,
2018. Graph Convolutional Neural Networks for Web-Scale Recommender Systems.
)에서는 메시지에 오직 \(e_i\)의 contribution만 고려됐었습니다.
하지만 NGCF는 \(e_i\)와 \(e_u\)사이의 상호작용을 \(\mathbf{e}_i \odot \mathbf{e}_u\)라는 (element-wise product) 형태로 메시지에 추가로 인코딩해줍니다.
이는 \(\mathbf{e}_i\)와 \(\mathbf{e}_u\) 사이의 유사성(또는 관련성, affinity)에 메시지가 의존하게 되죠.
예를 들어, 유사한 아이템 아이템들과는 \(\odot\) 값도 클 테니 유사한 아이템들의 정보를 더 많이 받게 되겠죠.
이는 모델의 표현 능력(representation ability)도 향상시킬 수 있고 자연히 추천 성능도 향상된다고 합니다. (증명은 실험 부분에서 한다고 하네요)



2017. Semi-Supervised Classification with Graph Convolutional Networks.처럼, 여기서는 graph Laplacian norm이라는 개념을 \(p_{ui}=\frac{1}{\sqrt{|N_u||N_i|}}\)을 도입합니다.
여기서 \(N_u\)과 \(N_u\)는 각각 유저 \(u\)와 아이템 \(i\)의 first-hop 이웃을 나타냅니다.
representation 학습의 관점에서 보면, \(p_{ui}\)는 아이템 \(i\)가 유저 \(u\)의 선호도에 얼만큼 공헌했는지를 의미합니다.
아이템 \(i\)를 소비한 유저가 많다면, 그 중 한 유저에게 보내는 메시지는 영향력이 적겠죠? 유저 입장에서도 마찬가지입니다.
유저 \(u\)가 아주 많은 아이템을 소비했다면, 그 중 특정 아이템 \(i\) 사이의 메시지 \(m_{u \leftarrow i}\)의 영향력이 줄어드는 것이 맞겠죠.



한편 메시지 패싱 관점에서는 \(p_{ui}\)를 감쇠 인자로 해석됩니다.
즉, 경로의 길이가 길어짐에 따라 공헌도가 감소해야 한다는 것을 반영합니다.

Message Aggregation

이제 유저 \(u\)의 이웃으로부터 전파되는 메시지들을 결합함으로써 \(u\)의 표현을 정교화(refine)합니다.
Aggregation의 함수는 다음과 같습니다:

\[e_u^{(1)} = \text{LeakyReLU}(m_{u \leftarrow u} + \sum_{i \in N_u} m_{u \leftarrow i})\]

\(e_u^{(1)}\)은 유저 \(u\)의 representation인데, 위첨자 \(^{(1)}\)은 첫 번째 임베딩 전파 레이어 이후 얻은 것을 의미합니다.
활성화 함수로 쓰이는 LeakyReLU는 양수가 들어오는 경우 그대로 통과시키고 음수는 0.01을 곱한 값을 내놓는 함수입니다.
주목할 점은 이웃 \(N_u\)로부터 전파된 메시지들 뿐만 아니라, 유저 \(u\)의 self-connection \(m_{u \leftarrow u}=W_1e_u\)을 고려했다는 것입니다.
\(m_{u \leftarrow u}\)는 원본 특징(original feature)의 정보를 보유하고 있습니다.
\(W_1\)은 \(m_{u \leftarrow i}\)에서 쓰였던 \(W_1\)과 동일한 가중치 행렬입니다.
같은 행렬이 다시 한 번 쓰이는 것입니다.
유사하게, 아이템 \(i\)에 대한 표현 \(e_i^{(1)}\)도 얻을 수 있습니다. 이 때는 연결된 유저들로부터의 정보를 전파하면 됩니다.





요약하자면 전파 레이어의 장점은 1차 연결 정보(first-order connection information)를 이용하여 유저와 아이템 각각의 표현을 연관짓게 한다는 것입니다!

2. High-order propagation

Figure2. NGCF 아키텍쳐. 화살표는 정보가 흐른다는 것을 의미한다. 그림 가장 밑에 \(u_1\)과 \(i_4\)가 있다. 각각 여러개의 임베딩 전파 레이어를 거치고 마지막엔 레이어의 아웃풋들이 concat되어, 최종 예측 스코어 계산에 쓰인다.

Figure3. \(u_1\)에 대한 3차(third-order) 임베딩 전파

1차로 얻은 연결성 모델링을 통해 좀 더 강화된(augmented) 표현을 얻었습니다. 레이어를 더 쌓아 고차원 연결의 정보를 얻을 수 있습니다.
이런 고차원 연결성(high-order connectivity)은 CF 시그널을 인코딩하는데에 매우 중요하겠죠?

\(l\)개의 전파 레이어를 쌓음으로써, 유저(혹은 아이템)은 자신의 \(l\)-hop으로부터 전파된 메시지를 받을 수 있습니다.
Figure 2를 통해 볼 수 있는 것처럼, \(l\)번째 스텝에서는 유저 \(u\)의 표현이 재귀적으로 다음과 같이 공식화됩니다:

\[e_u^{(l)} = \text{LeakyReLU}(m_{u \leftarrow u}^{(l)} + \sum_{i \in N_u}m_{u \leftarrow i}^{(l)})\]

그렇다면 \(l\)-hop으로부터 오는 메시지는 어떻게 공식화될까요? 다음과 같습니다. 이런 식으로 재귀적으로 수행되겠죠:

\[m_{u \leftarrow i}^{(l)} = p_{ui}(W_1^{(l)}e_i^{(l-1)} + W_2^{(l)}(e_i^{(l-1)} \odot e_u^{(l-1)}))\]

\[m_{u \leftarrow u}^{(l)}=W_1^{(l)} e_u^{(l-1)}\]

\(W_1^{(l)}, W_2^{(l)} \in \mathbb{R}^{d_l \times d_{l-1}}\)은 학습가능한 transformation 행렬이고, \(d_l\)은 변형 후 사이즈입니다.
\(e_i^{l-1}\)은 이전 스텝으로부터 생성된 아이템 표현입니다.
이 표현은 \((l-1)\)-hop 이웃으로부터의 메시지를 기억하고 있습니다.
Figure 3에서 볼 수 있듯이, \(u_1 \leftarrow i_2 \leftarrow u_2 \leftarrow i_4\)와 같은 collaborative signal이 전파 과정에 의해 학습될 수 있습니다.
\(i_4\)로부터의 메시지는 \(e_{u_1}^{(3)}\)에 명시적으로 인코딩됩니다.



\(4번 아이템\)i_4\(에서 1번 유저\)u_1\(까지의 메시지,\)m_{4 \leftarrow 1}$$가 어떻게 구해지는지 다시 한 번 천천히 살펴봅시다.

위와 같은 그래프(Figure 3과 동일)가 있다고 할 때, 가장 첫 작업(첫 번째 레이어)에서 \(u_2\)는 \(i_4\)로부터 오는 메시지를 받아 업데이트 될 것입니다.
즉, \(e_{u_2}^{(1)}\)은 \(i_4\) 정보를 포함하게 됩니다. 물론 이 단계에서 모든 아이템과 유저 임베딩이 동일하게 업데이트 될 것입니다.



두 번째 작업(레이어)에서는 \(i_2\) 주변 유저들로부터 메시지를 받아 업데이트 될 것입니다.
그런데 이 유저 중 한 명인 \(u_2\)는 이전 레이어에서 \(i_4\)의 정보를 포함하게 됐었죠.
그래서 두 번째 레이어까지 업데이트를 마친 결과, 결과적으로 \(i_4\)의 정보를 포함한 \(u_2\), \(u_2\)의 정보를 포함한 \(i_2\)가 되었습니다.



그 다음단계에서 \(u_1\)은 마찬가지로 주변 아이템 \(i_1, i_2, i_3\)로부터 메시지를 맞아 업데이트 되겠죠.
근데 \(i_2\)는 \(i_4\)의 정보까지 포함하고 있었네요.
따라서 이번 레이어에서의 작업을 마치면 \(u_1\)은 \(i_4\)의 정보까지 포함하게 될 것입니다.

즉, 메시지 전파를 전체적으로 3판(?) 수행하면 각 판마다 \(\mathbf{e}^1_{u_1}, \mathbf{e}^2_{u_1}, \mathbf{e}^3_{u_1}\)이 생길텐데, 이 중 \(\mathbf{e}^3_{u_1}\)은 \(\mathbf{e}^0_{i_4}\)를 받아들이게 되는 것이죠.

Propagation Rule in Matrix Form.

임베딩 전파 및 배치 수행을 위해서는, 실제로는 행렬을 이용해 연산을 수행합니다. 레이어 단위로 수행되는 전파는 아래 수식을 따릅니다.

\[E^{(l)} = \text{LeakyReLU}((\mathcal{L}+I)E^{(l-1)}W_1^{(l-1)} + \mathcal{L} E^{(l-1)} \odot E^{(l-1)} W_2 ^{(l)}  )\]

\(E\)의 shape는 \(E^{(l)} \in \mathbb{R}^{(N+M) \times d_l  }\) 입니다. \(N\)은 유저의 수, \(M\)은 아이템의 수입니다.

\(\mathcal{L}\)은 유저-아이템 그래프에 대한 Laplacian 행렬이며 다음과 같이 정의됩니다:

\[\mathcal{L} = \mathbf{D}^{-\frac{1}{2}}\mathbf{A}\mathbf{D}^{-\frac{1}{2}} \\
\\
\\ \;\;
\text{and}\;\; \mathbf{A}=\begin{bmatrix}
\mathbf{0}  &amp;amp; \mathbf{R} \\
\mathbf{R}^\top &amp;amp; \mathbf{0}
\end{bmatrix}\]

\(\mathbf{R} \in R^{N \times M}\)은 유저-아이템 상호작용 행렬이며, \(\mathbf{0}\)는 영행렬입니다.
\(\mathbf{A}\)는 인접행렬이며, \(\mathbf{D}\)는 대각 degree 행렬입니다.
\(\mathbf{D}\)의 \(t\)-th 대각 요소는 \(D_{tt} = |\mathcal{N}_t|\), 즉 이웃의 수 입니다.

뭔 말인가 싶어서 Laplacian 행렬에 대해 찾아보고 직접 예를 들어 계산해봤습니다.

\(\mathcal{L} = \mathbf{D}^{-\frac{1}{2}}\mathbf{A}\mathbf{D}^{-\frac{1}{2}}\)가 등장한 이유

\(\mathcal{L} = \mathbf{D}^{-\frac{1}{2}}\mathbf{A}\mathbf{D}^{-\frac{1}{2}}\)는 어떤 노드가 주변 노드의 정보를 aggregation할 때 그 message의 decay factor가 들어있는 행렬입니다.



논문에 나오는 그래프를 예로 들어봅시다. 3명의 유저와 5개의 아이템이 있습니다.
본 논문에서 정의한 인접행렬 \(\mathbf{A}\)에는 \(\mathbf{R}\)이라는 인터랙션 행렬이 블록행렬 형태로 들어가 있습니다.
인접행렬에서 1이었던 자리는 유저와 아이템의 인터랙션이 존재했음을 의미합니다.

Laplacian \mathcal{L} = \mathbf{D}^{-\frac{1}{2}}\mathbf{A}\mathbf{D}^{-\frac{1}{2}} 계산을 해봅시다.




  
    
      앞뒤로 각 노드의 degree의 $$\frac{1}{\sqrt{\mathcal{
      N
      }}}$$을 곱해주니까, 1이 있던 자리에는 유저의 이웃 수와 아이템의 이웃 수를 각각 루트를 씌워 역수를 취한 후 두 수를 곱한 수가 되었습니다.
    
  


이 숫자의 의미는 앞 장에서 설명했던 것처럼, 인기가 많은 아이템(다른 유저와 인터랙션이 많은 아이템)으로부터의 메시지의 정보 크기는 그 이웃 수만큼 줄인다는 것입니다.



\((\mathcal{L} + I)E\)를 수행하게 되면, 연결된 주변 노드로부터 decay factor가 곱해진 정보를 받아들여 더해지게 됩니다.

이제 \(E^{(l)} = \text{LeakyReLU}((\mathcal{L}+I)E^{(l-1)}W_1^{(l-1)} + \mathcal{L} E^{(l-1)} \odot E^{(l-1)} W_2 ^{(l)}  )\) 이 수식이 좀 보이시나요?
\(\mathcal{L}_{ui} = 1 / \sqrt{|\mathcal{N}_u||\mathcal{N}_i|} = p_{ui}\)가 됩니다. 이 수는 message construction에서 봤던 그 계수와 동일합니다.

행렬 계산 형태로 propagation을 수행함으로써, 우리는 모든 유저와 아이템에 대한 표현을 동시에 효과적으로, 한 번에 업데이트할 수 있습니다. Graph convolutional network(2018.
DeepInf: Social Influence Prediction with Deep Learning.)에서는 보통 노드 샘플링 과정이 있는데, 이렇게 행렬 계산을 함으로써 이 과정도 없어집니다.

3. Model Prediction

\(L\)번의 propagating을 거치고 난 후 유저 \(u\)에 대해 여러 개의 representation, 즉 \({ \mathbf{e}_u^{(1)}, \cdots, \mathbf{e}_u^{(L)} }\)을 얻게 된다.
각 레이어마다의 representation들은 다른 커넥션들을 거쳐 패싱되어왔기 때문에 유저의 선호도에 각기 다른 측면을 갖고 있다. 각각 공헌한다.
그래서 이들은 concat한다. 아이템도 똑같이
\(u\)와 \(i\)에 대한 final embedding은 다음과 같다.

\[\mathbf{e}_u^* = \mathbf{e}_u^{(0)} \parallel \cdots \parallel \mathbf{e}_u^{(L)}, \mathbf{e}_i^* = \mathbf{e}_i^{(0)} \parallel \cdots \parallel \mathbf{e}_i^{(L)}\]

최종적으로, 유저 \(u\)의 아이템 \(i\)에 대한 선호도를 계산하기 위해 내적한다.

\[\hat{y}_{\text{NGCF}} (u, i) = {\mathbf{e}_u^*}^\top \mathbf{e}_i^*\]

4. Optimization (BPR)

pairwise BPR loss (2009. BPR: Bayesian Personalized Ranking from Implicit Feedback.)를 최적화했다.
이는 추천시스템에서 광범위하게 쓰인다. 이는 관측된, 그리고 관측 안 된(observed and unobserved) 인터랙션 사이의 상대적인 순서를 고려합니다.
BPR은 ‘observed 아이템은 unobserved 아이템보다 유저의 선호도에 더욱 크게 반영되어야 하고, 더 높은 예측 값을 가져야한다’를 가정합니다.
목적 함수는 다음과 같습니다:

\[\text{Loss} = \sum_{(u, i, j) \in \mathcal{O}} -\ln \sigma (\hat{y}_{ui} - \hat{y}_{uj}) + \lambda \parallel \Theta \parallel_2^2\]

\(\mathcal{O} = \left\{ (u, i, j) | (u, i) \in \mathcal{R}^+ , (u, j) \in \mathcal{R}^- \right\}\)은 pairwise 형태의 학습 데이터입니다.
\(\mathcal{R}^+\)는 observed interactions을 ,\(\mathcal{R}^-\)는 unobserved interactions를 나타냅니다.

\(\sigma (\cdot)\)은 sigmoid function이구요. \(\Theta = \left\{ \mathbf{E}, \left\{ \mathbf{W}_1^{(l)}, \mathbf{W}_2^{(l)} \right\}_{l=1}^{L} \right\}\)는 모든 학습 가능한 파라미터들을 의미합니다.
그리고 \(\lambda\)는 파라미터의 오버피팅을 막기 위한 \(L_2\) regularization 강도를 조절합니다.

특히, \((u, i, j) \in \mathcal{O}\)는 랜덤하게 샘플링하는데, 이 때 \(L\)번의 propagation을 통해 representation \(\left[ \mathbf{e}^{(0)}, \cdots, \mathbf{e}^{(L)} \right]\)을 먼저 구하고, 그 다음에 손실 함수의 gradient를 사용하여 파라미터를 업데이트합니다.

</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>논문리뷰 - Prod2vec(E commerce in Your Inbox Product Recommendations at Scale)</title>
      <url>/2022/07/04/prod2vec/</url>
      <content type="text">논문 링크 : E commerce in Your Inbox  Product Recommendations at Scale

제안된 방법은 이전 구매 내역(이메일로 날라온 영수증)을 이용하여 그 영수증 안의 상품들을 학습하여 추천하는 방법이다. 영수증을 패키지 상품으로, 영수증 안의 상품들 목록을 패키지의 여행 일정으로 대응시켜 하나투어
패키지 상품 추천시스템에 적용 가능할지 확인해볼 필요가 있다. Prod2vec을 발전시킨 Meta-prod2vec이 네이버 상품 추천시스템 중 유사아이템 추천시스템에 참고되었다.

제안된 방법은 상품을 저차원 공간에서의 표현(representation)으로 학습하는 방법을 제안한다. 임베딩 공간 안에서 최근접 이웃을 찾음으로써 추천이 이루어진다.

\(\mathcal{S}\)는 이메일 영수증들의 집합으로써, N명의 유저로부터 얻어진 것이다. 유저의 로그는 \(s=(e_1, e_2, …, e_M)\)으로 구성되며 \(s \in \mathcal{S}\)이다.
각각의 이메일 e는 \(T_m\)개의 상품들 p로 구성되어있음.
즉, \(e_m = (p_{m_1}, p_{m_2}, …, p_{m_{T_m}})\)이다.

목적 : 각각의 상품 p의 D차원 표현인 \(\mathbf{v}_p\)를 찾는 것. 이 때 당연하지만 유사한 아이템은 근처에 위치해야함.

s는 이메일(e)의 시퀀스이며, 이메일은 product로 구성되어있다.

저차원의 상품 임베딩

prod2vec

prod2vec 모델은 NLP 분야에서의 용어를 빌리자면 구매 시퀀스를 문장으로, 시퀀스 안의 상품들을 단어로 보고 상품의 벡터 표현을 학습하는 것이다. 본 논문에서는 Skip-gram 방식[24]을 사용하였다.
그리하여 아래의 목적함수를 최대화시킨다. 목적함수란 만약 사각형을 가장 크게 만들고 싶다고 가정할때 사각형의 넓이같은 것을 의미한다. MLE가 대표적인 목적함수이다.

\[\mathcal{L} = \sum_{s \in \mathcal{S}} \sum_{p_i \in s} \sum_{-c \le j \le c, j \ne 0} \log \mathbb{P}(p_{i+j} \mid
p_i) \tag{3.1}\]

같은 \(s\) 안에 있는 상품들은 임의로 배열된다. \(\mathbb{P}(p_{i+j} \mid p_i)\)는 상품 \(p_i\)가 주어졌을 때 이웃하는 상품 \(p_{i+j}\)를 관측할 확률이며 아래와 같이
소프트맥스 함수로 정의된다.

\[\mathbb{P}(p_{i+j} \mid p_i) = \frac{\exp (\mathbf{v}^T_{p_i} \mathbf{v}&apos;\_{p_{i+j}})} {\sum_{p=1}^{P} \exp(
\mathbf{v}^T_{p_i} \mathbf{v}&apos;_p)} \tag{3.2}\]

\(\mathbf{v}_p\)는 인풋, \(\mathbf{v}&apos;_p\)은 아웃풋 벡터 표현을 의미한다. c는 컨텍스트의 길이이다. P는 단어의 수이다.



bagged-prod2vec

다수의 상품이 동시에 구매되었다는 정보를 고려하기 위해 skip-gram모델을 변형한 모델이다.
쇼핑백의 개념을 도입한다.
이 모델은 상품 수준이 아니라 영수증 수준에서 동작한다.
상품 벡터 표현은 아래와 같이 변형된 목적함수를 최대화함으로써 얻어진다.

\[\mathcal{L} = \sum_{s \in \mathcal{S}} \sum_{e_m \in s} \sum_{-n \lt j \lt n, j \ne 0} \sum_{k=1, \cdots , T_m} \log
\mathbb{P}(e_{m+j} \mid p_{mk}) \tag{3.3}\]

prod2vec(수식 3.1)과의 차이는 j가 상품 수준에서 영수증 수준으로 바뀌었다는 것이다. 다른 컨텍스트의 아이템과 연산.

\(\mathbb{P}(e_{m+j} \mid p_{mk})\)는 이웃하고 있는 영수증 \(e_{m+j}\)를 관측할 확률이다.
영수증 \(e_{m+j}\)는 상품으로 구성되어 있으므로 \(e_{m+j} = (p_{m+j}, \cdots, p_{m+j, T_m})\)이다.
상품 \(p_{mk}\)가 주어졌을 때 왜 한 단계 더 높은 수준인 영수증을 관측할 확률인가 헷갈릴 수도 있지만, \(\mathbb{P}(e_{m+j} \mid p_)\)는 다음과 같다.



상품 구매의 시간적 정보를 반영하기 위해서 directed 언어 모델을 제안했다.
이는 컨텍스트로서 미래의 상품만 사용하겠다는 것이다[12].
위처럼 수정함으로써 상품 임베딩값은 미래 있을 구매 여부를 예측할 수 있도록 학습된다.

상품-to-상품 예측 모델

저차원의 상품 표현을 학습하고 난 후 다음으로 구매 할 아이템을 예측하는데 있어 몇 가지 방법이 있다.

prod2vec-topK

구매한 상품이 주어지면, 모든 다른 상품들과 코사인 유사도를 계산해서 가장 유사한 top K 아이템을 추천함.

prod2vec-cluster

추천의 다양성을 위해 상품들을 여러 클러스터들로 그룹핑하고, 이전에 구매한 상품이 속해있는 클러스터와 가장 연관 있는 클러스터 내의 상품을 추천한다.
K-means 클러스터링을 썼으며, 상품 표현들 사이의 코사인 유사도를 기반으로 그룹핑했다.
\(C\)개의 클러스터가 있다고 하자.
\(c_1\)라는 클러스터에서 구매가 일어난 후 다음 구매는 Multinomial distribution \(\theta_{i1}, \theta_{i2}, \cdots, \theta_{iC}\)를 따른다.
\(\theta_{ij}\)는 \(c_i\)에서 구매가 일어난 다음 \(c_j\)에서 구매가 일어날 확률이며 다음과 같다.

\[\hat{\theta}_{ij} = \frac{\text{# of times } c_i \text{ purchase was followed by } c_j}{\text{count of } c_j \text{
purchased}} \tag{3.4}\]

구매했던 상품 \(p\)가 주어졌다 -&amp;gt; \(p\)가 어느 클러스터에 속하는지 확인 -&amp;gt; \(p\)가 만약 \(c_i\)라는 클러스터에 속해있다면 \(c_i\)와 가장 연관된 클러스터를 여러개 찾음 -&amp;gt; 그 속의
상품들과 \(p\)와 코사인 유사도를 계산하여 상위 K개를 추천한다.

</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>추천시스템과 Matrix Decompositions — 1. Determinant and Trace</title>
      <url>/2022/05/18/matrix-decomposition-01-determinant-and-trace/</url>
      <content type="text">Determinant는 선형 대수에서 중요한 개념이다. 
Determinant란 선형방정식 시스템의 분석 및 솔루션에 있어서, 수학적인 객체(mathematical object)이다. 
Determinant는 오직 정방행렬에 대해서만 정의된다. 
이 책에서는 determinant를 \(det(A)\) 또는 \(|A|\)로 표기한다.



정방행렬 A의 determinant란 A를 실수로 mapping하는 함수이다. determinant의 정의를 살펴보기 전에, 동기 부여를 위한 예시를 함께 보자.


  예제 4.1 (행렬 Invertibility 확인하기)

  정방행렬 A가 Invertible(Section 2.2.2)인지 아닌 지를 알아보자. 가장 작은 행렬의 경우 우린 행렬이 invertible일 때를 알고 있다. 만약 \(A\)가 1×1행렬이라면, 즉, 스칼라라면, \(A=a \rightarrow A^{-1}=\frac{1}{a}\)이다. \(a\ne0\)이라면 \(a \times (1/a)=1\)이 성립하기 때문이다. 2×2 행렬이라면, inverse의 정의(Definition 2.3)에 의해 \(AA^{-1}=I\)인 것을 알고 있다. 그러면 2.24와 함께 \(A\)의 inverse는 다음과 같다.





  그러므로, \(a_{11}a_{22}-a_{12}a_{21} \ne 0\) (4.3)이라면 \(A\)는 invertible하다. 바로 \(a_{11}a_{22}-a_{12}a_{21}\)라는 이 수가 2×2 행렬 A의 determinant이다. 즉, 다음과 같다.




예제 4.1은 determinant와 역행렬 존재 여부 사이의 관계를 나타낸다. 다음 theorem은 n × n 행렬에 대해 동일한 결과를 명시합니다.


어느 정방행렬 A에 대하여, \(det(A)\ne0\)라면 A는 invertible하다.

작은 행렬들에 대해서는 determinant의 명확한 표현이 존재한다. \(n=1\)일 때,



\(n=2\)일 때,



이는 앞선 예제에서 살펴본 바와 같다.

\(n=3\)일 때 Sarrus’ rule은 다음과 같다.



Sarrus’ rule의 곱셈항을 기억하기 위해서는 행렬 안의 세 가지씩 곱한 요소들을 잘 추적해야한다.

\(i&amp;gt;j\)에 대하여 \(T_{ij}=0\)라면 정방행렬 \(T\)를 upper-triangular matrix라고 한다. 
즉, 이 행렬은 대각선 밑으로는 0이다. 
비슷하게, lower-triangular matrix를 대각선 위가 0인 행렬로 정의한다. 
이와 같은 triangular 행렬 \(n × n\)의 \(T\)에 대하여, determinant는 대각 element들의 곱이다.




  예제 4.2 (부피 측정 수단으로서의 determinants)

  determinant의 개념을 보면, 우리는 이를 \(\mathbb{R}^n\)에서 어느 객체를 span하는 n개의 벡터들을 매핑하는 것으로 바라봐도 자연스럽다. 행렬 \(A\)의 determinant인 \(det(A)\)가 \(A\)의 column들로 형성되는 n차원의 평행 육면체의 부호를 가진 부피인 것이 알려져 있다. \(n=2\)일 때, 행렬의 각 column들은 평행사변형을 형성할 수 있다; Figure 4.2를 보자.



Fiture 4.2 벡터 b와 g에 의해 span되는 평행사변형의 넓이(그림자 진 지역)는 \(|det([b,g])|\)이다.

벡터들 사이의 각도가 작아질수록, 평행사변형의 넓이 또한 줄어든다. 
두 벡터 \(\boldsymbol{b}\), \(\boldsymbol{g}\)가 행렬 \(A\)의 column이라고 생각해보자. 
\(A=[\boldsymbol{b}, \boldsymbol{g}]\)이다. 
그럼 \(A\)의 determinant의 절댓값은 꼭지점 0, \(\boldsymbol{b}\), \(\boldsymbol{g}\), \(\boldsymbol{b}+\boldsymbol{g}\)로 이루어진 평행사변형의 넓이이다. 
만약 \(\boldsymbol{b}\)와 \(\boldsymbol{g}\)가 linearly dependent이어서 \(\boldsymbol{b}=\lambda \boldsymbol{g}\)라면(\(\lambda \in \mathbb{R}\)), 이들은 더 이상 2차원 평행사변형을 형성하지 않을 것이다. 
그러므로 그때의 넓이는 0이다. 
반대로, 만약 \(\boldsymbol{b}\), \(\boldsymbol{g}\)가 linearly independent이고 각각이 canonical basis 벡터 \(\mathbf{e}_1\), \(\mathbf{e}_2\)의 배수라면, 이들은 다음과 같이 쓰여질 수 있다.

\[\boldsymbol{b} = \begin{bmatrix}
b \\
0 
\end{bmatrix}\]

\[\boldsymbol{g} = \begin{bmatrix}
0 \\
g 
\end{bmatrix}\]

그러면 determinant는 다음과 같다.

\[\begin{vmatrix} b &amp;amp; 0 \\ 0 &amp;amp; g \end{vmatrix}\]

determinant의 부호는 \(\boldsymbol{b}\), \(\boldsymbol{g}\)의 standard basis (\(\mathbf{e}_1\), \(\mathbf{e}_2\))에 대한 방향을 나타낸다. 
우리의 그림에서는 \(\boldsymbol{g}\), \(\boldsymbol{b}\)로 뒤집는 것이 \(A\)의 column을 서로 바꾸고 그늘 진 지역의 방향을 역방향으로 바꾸는 것과 동일해진다. 이것이 바로 우리에게 친숙한 공식, ‘넓이=높이×길이’이다. 
이는 더 높은 차원으로도 이어진다. 
\(\mathbb{R}^3\)에서는, 평행 육면체의 모서리를 span하는 세 가지 벡터 \(\boldsymbol{r}, \boldsymbol{b}, boldsymbol{g} \in \mathbb{R}^3\)를 고려해보자. 
즉, 마주보는 면이 평행한 평행 육면체인 것이다. Figure 4.3을 보자.


Figure 4.3 세 벡터 r, g, b에 의해 span되는 평행육면체의 부피는 |det([r, b, g])|이다. determinant의 부호는 span중인 벡터들의 방향을 나타낸다.

3×3 행렬 \([\boldsymbol{r}, \boldsymbol{b}, \boldsymbol{g}]\)의 determinant의 절댓값은 도형의 부피이다. 
그러므로, determinant는 행렬을 구성하는 column 벡터들에 의해 형성되는 부호 있는 부피를 측정하는 함수로서 역할한다. 
세 선형 독립 벡터 \(\boldsymbol{r}, \boldsymbol{b}, boldsymbol{g} \in \mathbb{R}^3\)이 다음과 같이 주어졌다고 해보자.



이 벡터들을 행렬의 column으로 쓰는 것은 원하는 볼륨을 계산할 수 있도록 해준다.







\(n×n\) 행렬의 determinant를 계산하는 것은 \(n&amp;gt;3\)인 케이스를 풀기 위한 일반적인 알고리즘을 요구한다. 
이 경우에는 다음과 같이 살펴보자. 
Theorem 4.2는 \(n\timesn\)행렬의 determinant를 계산하는 일을 \((n-1)\times(n-1)\) 행렬의 determinant를 계산하는 문제로 축소시킨다. 
Laplace expansion (Theorem 4.2)을 재귀적으로 적용함으로써, 결과적으로는 \(2\times2\) 행렬의 determinant를 계산함으로써 \(n\times n\) 행렬의 determinant를 계산할 수 있다.



\(A_{k, j} \in \mathbb{R}^{(n-1)\ times (n-1)}\)는 \(A\)행렬에서 \(k\)행과 \(j\)열을 삭제하여 얻을 수 있는 submatrix이다.


  예제 4.3 (Laplace Expansion)
첫 번째 row을 따라 Laplace expansion을 적용해가며 아래와 같은 행렬 \(A\)의 determinant를 계산해보자.




식 4.13을 적용하면 결과는 다음과 같다.



식 4.6을 이용해서 모든 \(2 \times 2\) 행렬의 determinant를 계산하고, 아래와 같은 답을 얻을 수 있다.



위 결과를 Sarru’s rule을 이용해서 구한 결과와 비교해보자.

행렬 \(A \in \mathbb{R}^{(n \times n)}\)에 대한 determinant를 아래와 같은 특성을 가진다.


  행렬곱의 determinant는 각각의 determinant의 곱과 같다. \(det(AB)=det(A)det(B)\).
  전치(Transposition)를 해도 determinant는 변하지 않는다. 즉, \(det(A)=det(A^T)\).
  만약 \(A\)가 regular하다면 (invertible하다면), \(det(A^T)=\frac{1}{det(A)}\)이다.
  Similar 행렬(Definition 2.22)들은 determinant가 같다. 그러므로, linear mapping \(\Phi: V \rightarrow V\)에 대한 \(\Phi\)의 모든 transformation 행렬 \(A_\Phi\)의 determinant는 모두 같다. 그러므로, linear mapping의 basis를 어떻게 선택한다해도 determinant는 변하지 않는다.
  여러 개의 행/열을 다른 것에 더하는 것은 \(det(A)\)를 변화시키지 않는다.
  행/열에 \(\lambda \in \mathbb{R}\)을 곱하는 것이면 \(det(A)\)도 \(\lambda\)만큼 곱해진다. 특히, \(det(\lambda A)=\lambda^n det(A)\)이다.
  두 행/열을 뒤바꾸는 것은 \(det(A)\)의 부호를 변화시킨다.


마지막 세 가지의 특성때문에 가우시안 소거법(Gaussian elimination)(Section 2.1)을 이용해 \(det(A)\)를 계산할 수 있다. 
바로 \(A\)를 row-echelon form으로 변환함으로써 말이다. 
\(A\)가 triangular form이 될 때까지 수행하면 된다. 
즉 \(A\)의 대각 요소 아래 쪽이 모두 0이면 된다. 
식 4.8을 다시 생각해보자. 
triangular 행렬의 determinant는 대각 요소들의 곱이었다.


정방 행렬 \(A \in \mathbb{R}^{n \times n}\)이 있을 때, \(rk(A)=n\)이라면 \(det(A) \ne 0\)이다. 즉, \(A가\) full rank라면 A는 invertible하다.

수학이 주로 손으로 쓰여졌던 시절에는 행렬의 invertibility를 알아내기 위하여 determinant 계산이 필수적이었다. 
그러나, 머신러닝 분야에서의 현대적인 접근은 바로 직접적인 숫자적 방법을 사용하는 것이다. 
이것이 determinant를 하나하나 계산하는 것을 대체할 수 있다. 
예를 들면, 챕터 2에서 우리는 가우시안 소거법으로 역행렬을 구하는 방법을 배웠었다. 
그러므로 가우시안 소거법은 행렬의 determinant를 계산하는데에 사용될 수 있다.

Determinant는 다음 섹션에서 이론적으로 중요한 역할을 한다. 
특히 특성 방정식(characteristic polynomial)을 이용해 eigenvalues와 eigenvectors를 배울 때 그렇다.


  Definition 4.4. 정방행렬 \(A \in \mathbb{R}^{n \times n}\)의 trace는 아래와 같이 정의된다.




즉, trace는 \(A\)의 대각 요소들의 합이다.

trace는 다음과 같은 특성들을 만족한다:


  
\[tr(A+B)=tr(A) + tr(B) \text{for} A, B \in \mathbb{R}^{n \times n}\]
  
  
\[tr(\alpha A) = \alpha tr(A), \alpha \in \mathbb{R} \text{for} A \in \mathbb{R}^{n \times n}\]
  
  
\[tr(I_n)=n\]
  
  
\[tr(AB)=tr(BA) \text{for} A \in \mathbb{R}^{n \times k}, B \in \mathbb{R}^{k \times n}\]
  


trace의 행렬곱에 대한 특성들은 좀 더 일반적이다. 특히, trace는 cyclic permutations에 invariant하다. 즉, 행렬 \(A \in \mathbb{R}^{a \times k}, K \in \mathbb{R}^{k \times l}, L \in \mathbb{R}^{l \times a}\)에 대하여



식을 만족한다. 이 특성은 행렬이 임의의 개수여도 적용된다. 식 (4.19)의 특별한 경우로, 두 벡터 \(x, y \in \mathbb{R}^n\)에 대하여 다음과 같다.



\(V\)가 벡터 공간이라 하고 linear mapping \(\Phi : V \rightarrow V\)가 주어졌을 때, \(\Phi\) 행렬의 trace를 사용하여 이 매핑의 trace를 정의할 수 있다. 
\(V\)의 basis가 주어졌을 때, transformation 행렬 \(A\)를 이용하여 \(\Phi\)를 설명할 수 있다. 
그러면 \(\Phi\)의 trace는 \(A\)의 trace이다. 
\(V\)의 basis가 달라진다면, \(\Phi\)에 대응하는 transformation 행렬 \(B\)는 적절한 \(S\)에 대한 \(S^{-1}AS\)처럼 basis를 바꿈으로써 얻어질 수 있다(Section 2.7.2). 
\(\Phi\)의 대응하는 trace에 대하여, 다음과 같다.



그러므로, linear mapping의 행렬 표현이 basis에 dependent한 반면 linear mapping Φ의 trace는 basis에 independent하다.

이번 섹션에서는 정방 행렬을 특성화하는 함수로서의 determinant와 trace에 대해 다뤘다. 
이 두 가지에 대한 이해를 바탕으로 이제는 행렬 \(A\)를 설명하는 중요한 식을 특성 다항식의 관점에서 정의할 수 있다. 
이는 다음 섹션에서 광범위하게 다뤄질 것이다.



이 때 \(c_0, \cdots, c_{n-1} \in \mathbb{R}\)이며, 위 식은 \(A\)의 특성방정식이라고 불린다. 특히,



를 만족한다. 특성 방정식(4.22a)는 다음 섹션에서 다룰 eigenvalue와 eigenvector를 계산하도록 도와준다.

끝! 다음은 4.2 Eigenvalues and Eigenvectors.


본 게시글은 ‘Mathematics of Machine Learning’ 책을 번역하였습니다. 한 호흡에 읽히도록, 복습 시 빨리 읽히도록 적어 놓는 것이 이 글의 목적입니다.
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Maximum Likelihood Estimation</title>
      <url>/2022/04/27/maximum-likelihood-estimation/</url>
      <content type="text">유튜버 AI Holic님의 ‘Likelihood 쉽게 설명드려요 — 머신러닝, 인공지능을 위한 수학’ 영상을 보고 정리하였음.

확률.

우도에 대해 알아보기 전에, 일단 가장 친숙한 확률이라는 것부터 살펴보자. 고양이들 1,000마리의 몸무게를 재서 다음과 같은 히스토그램 분포가 나왔다고 해보자. 평균은 4, 표준편차는 0.5라고 해보자.



“확률”이란, 다음처럼 우리가 고등학교 때 많이 구하던 바로 그것이다!



평균은 얼마고, 표준편차는 얼마일 때, 몸무게가 4보다 크거나 같고 5보다 작거나 같을 확률은 얼마인가?

\[\mathbb{P}(4 \le \text{몸무게} \le 5|\mathcal{N}(4, 0.5)) =0.477\]

평균은 얼마고, 표준편차는 얼마일 때, 몸무게가 3.5보다 크거나 같고 4보다 작거나 같을 확률은 얼마인가?

\[\mathbb{P}(3.5 \le \text{몸무게} \le 4|\mathcal{N}(4, 0.5)) =0.34\]



“확률”이란…

사건의 범위는 변하지만, 분포는 고정되어 있는 형태다. 내가 한 마리의 고양이를 키우고 있다고 가정해보자. 위의 분포에서는, 즉, 내가 관측한 고양이들의 몸무게들 중에서는, 내 고양이의 몸무게가 4kg에서
5kg사이일 확률은 47.7%이고, 3.5kg에서 4kg 사이일 확률은 34%이다.

\[\mathbb{P}(\text{data} | \text{distribution})\]

보통 “확률”이란, 위와 같은 형태이다. distribution이 정해져 있는 상태에서, 지금 이 데이터가 관측 될 확률이다.



그럼 Likelihood는 무엇일까?

아래 그림을 보자.



우리집 고양이가 5kg이라고 해보자. (뚱냥이다!)

우리집 뚱냥이의 몸무게라는 데이터(5kg)를 내가 관측했다. 그럼 이 데이터는 어떤 분포로부터 나왔다고 하는 게 가장 말이 될까?

만약 고양이 몸무게의 진짜, 온 세상 모든 고양이의 진리적인 분포가 위 그림처럼 평균 4, 분산 0.5인 정규분포라고 가정해보자. 그럼 이 가정 하에서 우리집 뚱냥이의 likelihood는? 0.108이다.

x=5인 경우의 확률분포의 y절편에 해당한다. 즉, 세로 선의 길이이다.

\[\mathcal{L}(\mathcal{N}(4, 0.5) | \text{고양이몸무게}=5)=0.108\]

“고양이 몸무게가 5kg이라고 주어졌을 때, 정규분포 (4, 0.5)의 likelihood는 0.108이다”라고 해석한다.

다시다시, 분포를 오른쪽으로 조금 움직여봅시다!



\[\mathcal{L}(\mathcal{N}(5, 0.5) | \text{고양이몸무게}=5)=0.798\]

내 고양이 몸무게가 5kg일 때, 이 데이터가 정규분포(5, 0.5)라는 분포의 likelihood는 0.798이다.

likelihood가 가장 높은 분포를 선택하는 것이 가장 말이 된다는 것은 이해가 간다. 아니 근데, 관측한 데이터로 분포를 때려 맞춘다고 했는데, 그 분포(분포란 평균과 표준편차를 의미함)의 likelihood
계산은 어떻게 하는가?



likelihood

=지금 얻은 데이터(내 뚱냥이 몸무게 = 5kg)가 이 분포로부터 나왔을 가능도

=각 데이터 샘플에서 후보 분포에 대한 높이(likelihood, 기여도)의 곱(iid)

다시다시, 내가 여러 마리의 고양이 몸무게를 측정했다(나는 현재 x들을 알고있다).

그렇다면, 이 몸무게들의 원래 분포는 무엇일까? → \(\theta\)는 무엇일까? → 이 글의 경우에는 정규분포라고 가정했으므로 \(\theta\)가 무엇일까?는 곧 평균과 분산이 무엇일까?가 된다.

→ 이 과정이 바로 최대 우도 추정이다. \(\mathbb{P}(x | \theta)\)가 가장 커지는 \(\theta\)를 추정하는 것이 가장 그럴 듯하다. 즉, 최대 우도 추정이란, \(\mathbb{P}(x |
\theta)\)가 가장 커지는 \(\theta\)(여기서는 평균과 표준편차)를 구하는 것이고, 모든 데이터를 이 분포에 빗대어 likelihood를 구해 모두 곱하고, 이 값이 가장 커지는 \(\theta\)를
구하는 과정이다.

똑똑한 누군가는 말한다.


  “이 \(\theta\)일 때, 즉 이 분포일 때, 내가 측정한 고양이들의 몸무게 x들이 가장 나옴직해!”

</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>LSTM(1997) 정리</title>
      <url>/2022/04/14/lstm/</url>
      <content type="text">원 논문 : Hochreiter, S., &amp;amp; Schmidhuber, J. (1997). Long short-term memory. Neural computation, 9(8), 1735–1780.

“밑바닥부터 시작하는 딥러닝 2”를 옮겼습니다. 그림은 직접 그렸습니다.



RNN의 문제점은 무엇일까?
언어 모델은 현재까지 앞 단어들이 주어지면 다음 단어를 예측한다. 그런데 아래와 같이 긴 문장이 주어진 경우를 보자.


  Tom was watching TV in his room. Mary came into the room. Mary said hi to [?]


[?]에 들어갈 단어는 당연히 Tom이다. 모델이 해야할 일은 무엇일까? 앞의 모든 단어가 주어지면 Tom을 가장 높은 확률로 예측하도록 학습해야 한다. 학습 시에 모델에게 정답인 ‘Tom’이 주어졌다고 해보자. 그럼 loss를 역전파하여 파라미터를 업데이트 해야 할텐데, RNN은 이 과정에서 순탄치 못하다. RNN은 맨 앞에 있는 Tom까지 의미 있는 기울기를 전달하기 힘들어하기 때문이다.

왜 그럴까? 결론적으로는 tanh함수와 행렬곱 연산때문에 그렇다. 위의 예에서는 단어가 약 20개 가까이 되는데, 그만큼 tanh 계산도 20번 존재한다. tanh의 미분값은 0~1사이로, 역전파로 한 번 지날 때마다 무조건 기울기가 작아진다. 행렬곱 계산도 마찬가지다. 위의 예로 치면 약 20번 동안 같은 행렬을 계속 곱하는 작업을 하게 된다. 이 행렬곱 노드에서 20번 역전파 하게 되면 기울기 폭발 또는 소실이 쉽게 일어난다.

기울기 폭발의 전통적 해결법은 기울기 클리핑(gradient clipping)이다. 기울기의 L2 norm이 특정 threshold를 넘으면 다시 줄여주는 단순한 방법이다.

그렇다면 기울기 소실은?

이를 해결하려면 RNN의 근본부터 뜯어 고쳐야 하며, 게이트를 추가한 모델인 LSTM과 GRU가 대표적이다. 게이트란 말 그대로 ‘문’이라는 뜻으로, 핵심은 기억 셀이라는 것이 여러 개의 게이트를 통과하며 어떤 정보를 기억할 지, 망각할 지를 학습하게 된다.



LSTM의 핵심은 기억 셀(memory cell, cell state, c)이다.

이 기억 셀은 외부로는 출력 되지 않는다. 단지 망각해야할 정보, 기억해야 할 정보와 계속 연산해 나간다.



기억 셀 기준으로 어떤 연산이 이루어지는지 살펴보면 편하다. 
\(c_{t-1}\)이 \(c_t\)로 되는 과정은 위 그림과 같다. 
일단 모든 연산이 이전 hidden state인 \(h_{t-1}\)과 현재 인풋 단어 \(x\)로부터 시작한다. 
그럼 이제 저 구름 안에서는 어떤 연산이 벌어지는 지를 하나하나 보면 된다.

1. 망각의 문, forget gate

\(c_{t-1}\)가 통과하는 첫 번째 게이트는 망각의 문이다. \(f\)라는 게이트는 아래와 같은 수식으로 얻어진다.



\[f=\sigma(x_tW_x^f + h_{t-1}W_h^f + b^f)\]

이것이 forget gate이다. 
이를 \(c_{t-1}\)과 원소별 곱을 한다.

2. 기억의 문, input gate

다음으로 지날 문은 기억의 문 \(i\)이다. 
마찬가지로 \(h_{t-1}\)과 \(x\)를 사용한다. 
우선 \(i\)를 구하기 위해선 우선 \(g\)라는 정보가 필요하다. 
아래 그림과 같은 연산을 거친 뒤 \(g\)라는 정보가 탄생한다.



\[g=\sigma(x_t W_x^g + h_{t-1} W_h^g + b^g)\]

이를 책에서는 ‘새로운 기억 셀’이라고 한다. 원 논문에는 어떤 표현으로 쓰였는지는 잘 모르겠다.

3. 나가는 문, output gate

\(c_t\)에는 과거부터 현재(\(t\))까지, 필요한 모든 정보가 담겨있다. 
당장은 그렇지 않더라도 학습을 통해 그렇게 만들어져 갈 것이다. 
이 \(c_t\)를 가지고 외부에 출력할 hidden state \(h_t\)를 만들 것이다. 
\(c_t\)에 \(\tanh\)를 적용하여 \(h_t\)를 만든다.

\[h_t = \tanh(c_t)\]

\(c_t\)의 각 원소에 \(\tanh\)를 적용하였다. 
근데 마지막으로 한번 더 \(h_t\)에 게이트를 하나 더 지나게 한다. 
이를 output gate라고 한다. 
이제 이 셀을 나가는 문이다. 
문의 이름은 \(o\)이다.



\[o=\sigma(x_t W_x^o + h_{t-1} W_h^o + b^o)\]

output gate인 \(o\)는 “\(\tanh(c_t)\)가 다음 hidden state \(h_t\)에 얼마나 중요한가”, “\(\tanh(c_t)\)를 얼마나 흘려보낼까?”를 결정한다. 
그러므로 \(o\)와 \(\tanh(h_t)\)를 원소별 곱을 수행하면 \(h_t\)를 얻는다.

근데 어떤 건 sigmoid를 쓰고 어떤 것은 tanh를 썼다. 
tanh의 출력은 -1~+1이다. 
이는 ‘인코딩 된 정보의 강약’을 의미할 수 있다. 
반면 sigmoid는 0~1의 값이므로 ‘얼마나 흘려보낼 지를 정하는 게이트(문)’이라고 생각할 수 있다. 
따라서 게이트에는 sigmoid가, 정보를 품는 작업에는 tanh가 쓰인다.

이 문들이 어떤 원리로 “기울기 소실 문제”를 해결한단 말일까?


기억 셀의 역전파

기억 셀의 역전파를 보면, 더하기와 곱하기 밖에 없다. 
더하기는 역전파 시 그대로 흘러가므로 기울기에 아무 연산도 하지 않고 흘러간다. 
그리고 곱하기는 매 시각 다른 f와의 아다마르 곱(원소별 곱)이다.

기존 RNN은 계속 같은 행렬을 행렬곱 했었기에 기울기가 폭발하거나 소실됐었다. 
그러나 LSTM의 기억 셀은 매번 다른 행렬과 아다마르 곱을 수행하므로 기울기 폭발이나 소실이 일어나기 힘들다.

곱하기는 forget gate와의 곱이므로, 순전파 때 0~1사이의 값이 곱해지는 과정이었다. 
‘잊어야 한다’고 판단된 셀에서는 기울기가 작아진채로 역전파된다. 
그러나 ‘잊어서는 안된다’라고 판단된 셀에서는 기울기가 작아지지 않고 전파된다.

따라서, 기억 셀이 장기 의존 관계를 유지(학습)할 수 있다.

</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
